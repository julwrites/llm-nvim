==============================================================================
lua/llm/api.lua
==============================================================================
    -- llm/api.lua - Public API surface for llm-nvim
    -- License: Apache 2.0

 13 local M = {}
 13 local facade = require('llm.facade')
 13 local config = require('llm.config')
 13 local job = require('llm.core.utils.job')
 13 local ui = require('llm.core.utils.ui')


    --- Setup function for plugin configuration
    -- @param opts table: Configuration options table
    -- @return table: The API module
 13 function M.setup(opts)
**0   config.setup(opts)
**0   return M
    end

    --- Get current plugin version
    -- @return string: Version string
 13 function M.version()
**0   return require('llm.config').version
    end

    -- Expose all facade functions through API
 91 for name, fn in pairs(facade) do
      M[name] = function(...)
**0     return fn(...)
      end
    end

    --- A unified function for running LLM commands and handling streaming output.
    -- @param command_parts table: The command and its arguments.
    -- @param prompt string: The prompt to send to the command's stdin.
    -- @param callbacks table: A table with on_stdout, on_stderr, and on_exit callbacks.
    -- @return number: The job ID, or nil if the job failed to start.
 13 function M.run_llm_command(command_parts, prompt, callbacks)
**0   local job_instance = job.run({
        command = command_parts,
        on_stdout = callbacks.on_stdout,
        on_stderr = callbacks.on_stderr,
        on_exit = callbacks.on_exit,
      })

**0   if job_instance and job_instance.id then
**0     vim.fn.jobsend(job_instance.id, prompt)
**0     return job_instance.id
      end

**0   return nil
    end

 13 function M.run_streaming_command(command_parts, prompt, callbacks)
  5   callbacks = callbacks or {}
 10   local job_id = job.run(command_parts, {
  5     on_stdout = callbacks.on_stdout,
  5     on_stderr = callbacks.on_stderr,
  5     on_exit = callbacks.on_exit,
      })

  5   if job_id then
  4     if prompt and prompt ~= "" then
  2       vim.fn.jobsend(job_id, prompt)
        end
  4     vim.fn.jobclose(job_id, "stdin")
      end

  5   return job_id
    end

    --- Runs an LLM command with streaming output to a specified buffer.
    -- @param cmd_parts table: The command and its arguments as a table.
    -- @param bufnr number: The buffer number to stream output to.
    -- @param opts table: Optional table with additional callbacks (on_stdout, on_stderr, on_exit).
    -- @return number: The job ID if the job started successfully, otherwise nil.
 13 function M.run_llm_command_streamed(cmd_parts, bufnr, opts)
**0   opts = opts or {}
**0   local callbacks = {
        on_stdout = function(_, data)
**0       if data then
**0         for _, line in ipairs(data) do
**0           ui.append_to_buffer(bufnr, line .. "\n", "LlmModelResponse")
            end
          end
**0       if opts.on_stdout then opts.on_stdout(_, data) end
        end,
        on_stderr = function(_, data)
**0       if data then
**0         for _, line in ipairs(data) do
**0           vim.notify("LLM stderr: " .. line, vim.log.levels.ERROR)
            end
          end
**0       if opts.on_stderr then opts.on_stderr(_, data) end
        end,
        on_exit = function(_, exit_code)
**0       vim.notify("LLM command finished with exit code: " .. tostring(exit_code), vim.log.levels.INFO)
**0       if opts.on_exit then opts.on_exit(_, exit_code) end
        end,
      }

**0   return M.run_streaming_command(cmd_parts, nil, callbacks)
    end

    -- Add API documentation metadata
 13 M.__name = 'llm.api'
 13 M.__description = 'Public API surface for llm-nvim plugin'

 13 return M

==============================================================================
lua/llm/chat.lua
==============================================================================
    -- llm/chat.lua - Chat Orchestration
    -- License: Apache 2.0

 26 local M = {}
 26 local config = require('llm.config')
 26 local ChatSession = require('llm.chat.session').ChatSession
 26 local ChatBuffer = require('llm.chat.buffer').ChatBuffer

    -- Track active chat sessions by buffer number
 26 local active_sessions = {}

    --- Start a new chat session
    -- @param opts table: Chat options
    --   - model: string (optional) - Model to use
    --   - system_prompt: string (optional) - System prompt
    --   - fragments: table (optional) - List of fragment paths
    -- @return table: { session, buffer }
 26 function M.start_chat(opts)
 11   opts = opts or {}
      
      -- Create session
 22   local session = ChatSession.new({
 11     model = opts.model,
 11     system_prompt = opts.system_prompt,
 11     fragments = opts.fragments,
      })
      
      -- Create buffer
 22   local buffer = ChatBuffer.new({
 11     model = opts.model or config.get("model"),
 11     system_prompt = opts.system_prompt or config.get("system_prompt"),
      })
      
      -- Link session to buffer
 11   session.bufnr = buffer:get_bufnr()
      
      -- Store session for later access (keep table with metatables intact)
 11   active_sessions[buffer:get_bufnr()] = {
 11     session = session,
 11     buffer = buffer,
 11   }
      
      -- Store reference in buffer variable for keymap access
      -- Note: Store the active_sessions reference, not a copy
 11   vim.b[buffer:get_bufnr()].llm_chat_bufnr = buffer:get_bufnr()
      
 11   if config.get('debug') then
**0     vim.notify(
**0       string.format("[Chat] Started new chat session in buffer %d", buffer:get_bufnr()),
**0       vim.log.levels.DEBUG
        )
      end
      
 11   return {
 11     session = session,
 11     buffer = buffer,
 11   }
    end

    --- Send message from current buffer
    -- Called by keymap (<C-CR> or <Leader>s)
 26 function M.send_message()
  4   local bufnr = vim.api.nvim_get_current_buf()
      
      -- Get chat data from active_sessions using buffer number
  4   local chat_bufnr = vim.b[bufnr].llm_chat_bufnr
  4   if not chat_bufnr then
  1     vim.notify("Not a chat buffer", vim.log.levels.ERROR)
  1     return
      end
      
  3   local chat_data = active_sessions[chat_bufnr]
  3   if not chat_data then
**0     vim.notify("Chat session not found", vim.log.levels.ERROR)
**0     return
      end
      
  3   local session = chat_data.session
  3   local buffer = chat_data.buffer
      
      -- Check if session is ready
  3   if not session:is_ready() then
  1     vim.notify("Chat is processing, please wait", vim.log.levels.WARN)
  1     return
      end
      
      -- Get user input
  2   local prompt = buffer:get_user_input()
      
  2   if not prompt or prompt == "" then
  1     vim.notify("Cannot send empty message", vim.log.levels.WARN)
  1     return
      end
      
      -- Switch to normal mode if in insert mode
  1   if vim.fn.mode() == 'i' then
**0     vim.cmd('stopinsert')
      end
      
      -- Update status
  1   buffer:set_status("Processing...")
      
      -- Add user message to history
  1   buffer:append_user_message(prompt)
      
      -- Clear input area
  1   buffer:clear_input()
      
      -- Send prompt to LLM
  2   local job_id = session:send_prompt(prompt, {
        on_stdout = function(_, data)
**0       if data then
**0         for _, line in ipairs(data) do
              -- Skip conversation ID lines (they'll be extracted by session)
**0           if not line:match("^Conversation ID:") then
**0             buffer:append_llm_message(line .. "\n")
              end
            end
          end
        end,
        
        on_stderr = function(_, data)
**0       if data then
**0         for _, line in ipairs(data) do
**0           vim.notify("LLM error: " .. line, vim.log.levels.ERROR)
            end
          end
        end,
        
        on_exit = function(_, exit_code)
**0       if exit_code == 0 then
**0         buffer:set_status("Ready")
            
            -- Update conversation ID in buffer if this was first message
**0         local conv_id = session:get_conversation_id()
**0         if conv_id then
**0           buffer:update_conversation_id(conv_id)
            end
            
            -- Add blank line after LLM response
**0         buffer:append_llm_message("")
            
            -- Focus input for next message
**0         buffer:focus_input()
            
**0         if config.get('debug') then
**0           vim.notify(
**0             string.format("[Chat] Message completed (conversation: %s)", conv_id or "unknown"),
**0             vim.log.levels.DEBUG
              )
            end
          else
**0         buffer:set_status("Error")
**0         vim.notify(
**0           string.format("LLM command failed with exit code: %d", exit_code),
**0           vim.log.levels.ERROR
            )
          end
        end,
      })
      
  1   if not job_id then
**0     buffer:set_status("Error")
**0     vim.notify("Failed to start LLM command", vim.log.levels.ERROR)
      else
  1     if config.get('debug') then
**0       vim.notify(
**0         string.format("[Chat] Started job %d for message", job_id),
**0         vim.log.levels.DEBUG
          )
        end
      end
    end

    --- Start a new message in the input area
    -- Called by keymap (<C-n>)
 26 function M.new_message()
  2   local bufnr = vim.api.nvim_get_current_buf()
  2   local chat_data = vim.b[bufnr].llm_chat_session
      
  2   if not chat_data then
  1     vim.notify("Not a chat buffer", vim.log.levels.ERROR)
  1     return
      end
      
  1   local buffer = chat_data.buffer
      
      -- Clear input and focus
  1   buffer:clear_input()
  1   buffer:focus_input()
      
  1   if config.get('debug') then
**0     vim.notify("[Chat] Cleared input for new message", vim.log.levels.DEBUG)
      end
    end

    --- Get active session for a buffer
    -- @param bufnr number: Buffer number
    -- @return table|nil: Chat session data or nil
 26 function M.get_session(bufnr)
  2   return active_sessions[bufnr]
    end

    --- Stop current job in active chat buffer
 26 function M.stop_current_job()
  2   local bufnr = vim.api.nvim_get_current_buf()
  2   local chat_data = vim.b[bufnr].llm_chat_session
      
  2   if not chat_data then
  1     vim.notify("Not a chat buffer", vim.log.levels.ERROR)
  1     return
      end
      
  1   local session = chat_data.session
  1   session:stop_current_job()
      
  1   local buffer = chat_data.buffer
  1   buffer:set_status("Stopped")
      
  1   vim.notify("Stopped current LLM job", vim.log.levels.INFO)
    end

    --- Clean up session when buffer is deleted
    -- Set up autocmd to clean up when chat buffer is closed
 52 vim.api.nvim_create_autocmd("BufDelete", {
      callback = function(args)
**0     local bufnr = args.buf
**0     if active_sessions[bufnr] then
          -- Stop any running jobs
**0       local session = active_sessions[bufnr].session
**0       if session.current_job_id then
**0         session:stop_current_job()
          end
          
          -- Remove from active sessions
**0       active_sessions[bufnr] = nil
          
**0       if config.get('debug') then
**0         vim.notify(
**0           string.format("[Chat] Cleaned up session for buffer %d", bufnr),
**0           vim.log.levels.DEBUG
            )
          end
        end
      end,
    })

 26 return M

==============================================================================
lua/llm/chat/buffer.lua
==============================================================================
    -- llm/chat/buffer.lua - Chat Buffer UI Management
    -- License: Apache 2.0

 26 local M = {}
 26 local config = require('llm.config')

    --- ChatBuffer class for managing chat buffer UI
    -- @class ChatBuffer
 26 local ChatBuffer = {}
 26 ChatBuffer.__index = ChatBuffer

    -- Section markers
 26 local HEADER_START_MARKER = "╭─"
 26 local HEADER_END_MARKER = "╰─"
 26 local HISTORY_START_MARKER = "┌─ Conversation History "
 26 local HISTORY_END_MARKER = "└─"
 26 local INPUT_START_MARKER = "┌─ Your Message "
 26 local INPUT_END_MARKER = "└─"

    --- Create a new chat buffer
    -- @param opts table: Buffer options
    --   - model: string (optional) - Model name
    --   - conversation_id: string (optional) - Conversation ID
    --   - system_prompt: string (optional) - System prompt
    -- @return ChatBuffer: New buffer instance
 26 function ChatBuffer.new(opts)
 20   opts = opts or {}
      
      -- Create new vertical split
 20   vim.cmd('vnew')
 20   local bufnr = vim.api.nvim_get_current_buf()
      
      -- Configure buffer
 20   vim.api.nvim_buf_set_option(bufnr, 'buftype', 'nofile')
 20   vim.api.nvim_buf_set_option(bufnr, 'bufhidden', 'wipe')
 20   vim.api.nvim_buf_set_option(bufnr, 'swapfile', false)
 20   vim.api.nvim_buf_set_option(bufnr, 'filetype', 'markdown')
 20   vim.api.nvim_buf_set_option(bufnr, 'modifiable', true)  -- Allow modifications
      
      -- Set buffer name
 20   local model_name = opts.model or config.get("model") or "default"
 20   local conversation_id = opts.conversation_id or "new"
 20   local buffer_name = string.format("LLM Chat - %s (%s)", model_name, conversation_id)
 20   vim.api.nvim_buf_set_name(bufnr, buffer_name)
      
 20   local buffer = {
 20     bufnr = bufnr,
 20     model = opts.model,
 20     conversation_id = opts.conversation_id,
 20     system_prompt = opts.system_prompt,
 20     history_start_line = 0, -- Will be set after initialization
 20     history_end_line = 0,
 20     input_start_line = 0,
 20     input_end_line = 0,
      }
      
 20   setmetatable(buffer, ChatBuffer)
      
      -- Initialize buffer layout
 20   buffer:initialize_layout()
      
      -- Set up keymaps
 20   buffer:setup_keymaps()
      
      -- Set up highlights
 20   buffer:setup_highlights()
      
      -- Move cursor to input area
 20   buffer:focus_input()
      
 20   if config.get('debug') then
**0     vim.notify(
**0       string.format("[ChatBuffer] Created buffer %d", bufnr),
**0       vim.log.levels.DEBUG
        )
      end
      
 20   return buffer
    end

    --- Initialize buffer layout with sections
 26 function ChatBuffer:initialize_layout()
 20   local lines = {}
      
      -- Header line
 20   local model_display = self.model or config.get("model") or "default"
 20   local conv_id_display = self.conversation_id or "new"
 20   table.insert(lines, string.format("LLM Chat - %s (ID: %s) | Status: Ready", model_display, conv_id_display))
 20   table.insert(lines, "")
      
      -- Conversation history section
 20   self.history_start_line = #lines
 20   table.insert(lines, "No messages yet")
 20   self.history_end_line = #lines
 20   table.insert(lines, "")
      
      -- Input area section
 20   self.input_start_line = #lines
 20   table.insert(lines, "--- (<C-CR> to send) ---")
 20   table.insert(lines, "Type your message here...")
 20   self.input_end_line = #lines
      
      -- Set buffer content
 20   vim.api.nvim_buf_set_lines(self.bufnr, 0, -1, false, lines)
      
      -- Make history section read-only by default (we'll manage this programmatically)
      -- Neovim doesn't have per-line read-only, so we'll handle in keymaps
    end

    --- Set up buffer keymaps with proper scoping
 26 function ChatBuffer:setup_keymaps()
 20   local bufnr = self.bufnr
      
      -- Helper function to check if cursor is in input area
      local function is_cursor_in_input()
**0     local cursor = vim.api.nvim_win_get_cursor(0)
**0     local line = cursor[1]
**0     return line > self.input_start_line and line <= self.input_end_line
      end
      
      -- Auto-remove placeholder on insert mode entry
 40   vim.api.nvim_create_autocmd("InsertEnter", {
 20     buffer = bufnr,
        callback = function()
**0       local cursor = vim.api.nvim_win_get_cursor(0)
**0       local line_num = cursor[1]
          
          -- Check if cursor is in input area
**0       if line_num > self.input_start_line and line_num <= self.input_end_line then
**0         local line = vim.api.nvim_buf_get_lines(bufnr, line_num - 1, line_num, false)[1]
            
            -- Remove placeholder text if present
**0         if line and line:match("Type your message here") then
**0           vim.api.nvim_buf_set_lines(bufnr, line_num - 1, line_num, false, {""})
              -- Keep cursor at the now-empty line
**0           vim.api.nvim_win_set_cursor(0, {line_num, 0})
            end
          end
        end
      })
      
      -- <C-CR> to send prompt (works anywhere, but only sends if in input area)
 40   vim.api.nvim_buf_set_keymap(
 20     bufnr, 'i', '<C-CR>',
 20     '<Cmd>lua require("llm.chat").send_message()<CR>',
 20     { noremap = true, silent = true, desc = "Send message" }
      )
      
 40   vim.api.nvim_buf_set_keymap(
 20     bufnr, 'n', '<C-CR>',
 20     '<Cmd>lua require("llm.chat").send_message()<CR>',
 20     { noremap = true, silent = true, desc = "Send message" }
      )
      
      -- <Leader>s alternative to send
 40   vim.api.nvim_buf_set_keymap(
 20     bufnr, 'i', '<Leader>s',
 20     '<Cmd>lua require("llm.chat").send_message()<CR>',
 20     { noremap = true, silent = true, desc = "Send message" }
      )
      
 40   vim.api.nvim_buf_set_keymap(
 20     bufnr, 'n', '<Leader>s',
 20     '<Cmd>lua require("llm.chat").send_message()<CR>',
 20     { noremap = true, silent = true, desc = "Send message" }
      )
      
      -- q to close buffer
 40   vim.api.nvim_buf_set_keymap(
 20     bufnr, 'n', 'q',
 20     '<Cmd>bd<CR>',
 20     { noremap = true, silent = true, desc = "Close chat buffer" }
      )
      
      -- <C-n> to clear input and start new message
 40   vim.api.nvim_buf_set_keymap(
 20     bufnr, 'n', '<C-n>',
 20     '<Cmd>lua require("llm.chat").new_message()<CR>',
 20     { noremap = true, silent = true, desc = "New message" }
      )
      
 40   vim.api.nvim_buf_set_keymap(
 20     bufnr, 'i', '<C-n>',
 20     '<Cmd>lua require("llm.chat").new_message()<CR>',
 20     { noremap = true, silent = true, desc = "New message" }
      )
      
 20   if config.get('debug') then
**0     vim.notify("[ChatBuffer] Keymaps configured", vim.log.levels.DEBUG)
      end
    end

    --- Set up syntax highlighting for chat elements
 26 function ChatBuffer:setup_highlights()
      -- Define highlight groups
 20   vim.api.nvim_set_hl(0, 'LlmChatHeader', { fg = '#f8f8f2', bg = '#44475a', bold = true })
 20   vim.api.nvim_set_hl(0, 'LlmChatBorder', { fg = '#6272a4' })
 20   vim.api.nvim_set_hl(0, 'LlmChatUserTag', { fg = '#50fa7b', bold = true })    -- Green
 20   vim.api.nvim_set_hl(0, 'LlmChatLlmTag', { fg = '#bd93f9', bold = true })     -- Purple
 20   vim.api.nvim_set_hl(0, 'LlmChatStatus', { fg = '#8be9fd', italic = true })   -- Cyan
 20   vim.api.nvim_set_hl(0, 'LlmChatInputPrompt', { fg = '#ffb86c', italic = true }) -- Orange
      
      -- Apply highlights to header
 20   vim.api.nvim_buf_add_highlight(self.bufnr, -1, 'LlmChatBorder', 0, 0, -1)
 20   vim.api.nvim_buf_add_highlight(self.bufnr, -1, 'LlmChatStatus', 1, 0, -1)
 20   vim.api.nvim_buf_add_highlight(self.bufnr, -1, 'LlmChatBorder', 2, 0, -1)
    end

    --- Update conversation ID in header
    -- @param conversation_id string: New conversation ID
 26 function ChatBuffer:update_conversation_id(conversation_id)
  1   self.conversation_id = conversation_id
      
      -- Update buffer name
  1   local model_display = self.model or config.get("model") or "default"
  1   local buffer_name = string.format("LLM Chat - %s (%s)", model_display, conversation_id)
  1   vim.api.nvim_buf_set_name(self.bufnr, buffer_name)
      
  1   if config.get('debug') then
**0     vim.notify(
**0       string.format("[ChatBuffer] Updated conversation ID: %s", conversation_id),
**0       vim.log.levels.DEBUG
        )
      end
    end

    --- Set status message in header
    -- @param status string: Status message
 26 function ChatBuffer:set_status(status)
  1   self.current_status = status
  1   local model_display = self.model or config.get("model") or "default"
  1   local conv_id_display = self.conversation_id or "new"
  1   local new_line = string.format("LLM Chat - %s (ID: %s) | Status: %s", model_display, conv_id_display, status)
      
  1   vim.api.nvim_buf_set_lines(self.bufnr, 0, 1, false, { new_line })
  1   vim.api.nvim_buf_add_highlight(self.bufnr, -1, 'LlmChatStatus', 0, 0, -1)
    end

    --- Append user message to history
    -- @param message string: User message
 26 function ChatBuffer:append_user_message(message)
  1   if not message or message == "" then
**0     return
      end
      
      -- Get ALL current history content (everything between header and input section)
  2   local history_lines = vim.api.nvim_buf_get_lines(
  1     self.bufnr,
  1     2,  -- Start after header (line 0 is title, line 1 is blank)
  1     self.input_start_line,  -- Everything before input section
        false
  1   )
      
      -- Remove placeholder if exists
  1   if #history_lines == 1 and history_lines[1]:match("No messages yet") then
**0     history_lines = {}
      end
      
      -- Filter out any remaining placeholder lines
  1   local filtered_lines = {}
 12   for _, line in ipairs(history_lines) do
 11     if not line:match("No messages yet") then
 10       table.insert(filtered_lines, line)
        end
      end
  1   history_lines = filtered_lines
      
      -- Remove trailing blank line if exists
  1   if #history_lines > 0 and history_lines[#history_lines] == "" then
**0     table.remove(history_lines)
      end
      
      -- Add user message with tag
  1   table.insert(history_lines, "[You]")
      
      -- Split message by lines
  2   for line in message:gmatch("[^\r\n]+") do
  1     table.insert(history_lines, line)
      end
      
  1   table.insert(history_lines, "")
      
      -- Rebuild entire buffer to fix formatting
  1   self:rebuild_buffer(history_lines)
      
  1   if config.get('debug') then
**0     vim.notify(string.format("[ChatBuffer] Appended user message (%d history lines)", #history_lines), vim.log.levels.DEBUG)
      end
    end

    --- Append LLM message to history (supports streaming)
    -- @param text string: LLM response text
 26 function ChatBuffer:append_llm_message(text)
  1   if not text or text == "" then
**0     return
      end
      
      -- Get ALL current history content
  2   local history_lines = vim.api.nvim_buf_get_lines(
  1     self.bufnr,
  1     2,  -- Start after header
  1     self.input_start_line,  -- Everything before input section
        false
  1   )
      
      -- Remove placeholder if exists
  1   if #history_lines == 1 and history_lines[1]:match("No messages yet") then
**0     history_lines = {}
      end
      
      -- Filter out any remaining placeholder lines
  1   local filtered_lines = {}
 12   for _, line in ipairs(history_lines) do
 11     if not line:match("No messages yet") then
 10       table.insert(filtered_lines, line)
        end
      end
  1   history_lines = filtered_lines
      
      -- Remove trailing blank line if exists
  1   if #history_lines > 0 and history_lines[#history_lines] == "" then
**0     table.remove(history_lines)
      end
      
      -- Check if this is the first chunk of a new LLM response
  1   local is_new_response = #history_lines == 0 or 
  1                           history_lines[#history_lines] == "" or
  1                           history_lines[#history_lines]:match("^%[You%]") or
  1                           history_lines[#history_lines]:match("^%[LLM%]")
      
  1   if is_new_response then
**0     table.insert(history_lines, "[LLM]")
      end
      
      -- Append the text (handle streaming chunks)
  1   local lines = {}
  2   for line in text:gmatch("[^\r\n]+") do
  1     table.insert(lines, line)
      end
      
      -- If text ends with newline, add it
  1   if text:match("\n$") then
**0     table.insert(lines, "")
      end
      
  2   for _, line in ipairs(lines) do
  1     table.insert(history_lines, line)
      end
      
      -- Rebuild entire buffer to fix formatting
  1   self:rebuild_buffer(history_lines)
    end

    --- Rebuild entire buffer with current history
    -- @param history_lines table: Array of history lines
 26 function ChatBuffer:rebuild_buffer(history_lines)
  2   local lines = {}
      
      -- Header line
  2   local model_display = self.model or config.get("model") or "default"
  2   local conv_id_display = self.conversation_id or "new"
  2   local status_display = self.current_status or "Ready"
  2   table.insert(lines, string.format("LLM Chat - %s (ID: %s) | Status: %s", model_display, conv_id_display, status_display))
  2   table.insert(lines, "")
      
      -- History section
  2   self.history_start_line = #lines
      
      -- Add all history lines
 26   for _, line in ipairs(history_lines) do
 24     table.insert(lines, line)
      end
      
  2   self.history_end_line = #lines
  2   table.insert(lines, "")
      
      -- Input section
  2   self.input_start_line = #lines
  2   table.insert(lines, "--- (<C-CR> to send) ---")
  2   table.insert(lines, "Type your message here...")
  2   self.input_end_line = #lines
      
      -- Replace entire buffer
  2   vim.api.nvim_buf_set_lines(self.bufnr, 0, -1, false, lines)
      
  2   if config.get('debug') then
**0     vim.notify(
**0       string.format("[ChatBuffer] Rebuilt buffer: history_start=%d, history_end=%d", 
**0         self.history_start_line, self.history_end_line),
**0       vim.log.levels.DEBUG
        )
      end
    end

    --- Get user input from input section
    -- @return string: User input text
 26 function ChatBuffer:get_user_input()
      -- Get lines from input area (after the separator line)
  2   local input_lines = vim.api.nvim_buf_get_lines(
  1     self.bufnr,
  1     self.input_start_line + 1,
  1     self.input_end_line + 1,
        false
  1   )
      
      -- Filter out placeholder text
  1   local cleaned_lines = {}
 12   for _, line in ipairs(input_lines) do
        -- Skip placeholder text
 11     if not line:match("^Type your message here") then
 11       table.insert(cleaned_lines, line)
        end
      end
      
  1   local input = table.concat(cleaned_lines, "\n")
      
      -- Trim whitespace
  1   input = input:gsub("^%s+", ""):gsub("%s+$", "")
      
  1   if config.get('debug') then
**0     vim.notify(
**0       string.format("[ChatBuffer] Got user input: %s", input),
**0       vim.log.levels.DEBUG
        )
      end
      
  1   return input
    end

    --- Clear input area
 26 function ChatBuffer:clear_input()
      -- Reset input section with placeholder
  1   local input_lines = {
  1     "--- (<C-CR> to send) ---",
        "Type your message here...",
  1   }
      
      -- Replace input section
  2   vim.api.nvim_buf_set_lines(
  1     self.bufnr,
  1     self.input_start_line,
  1     self.input_end_line + 1,
  1     false,
        input_lines
  1   )
      
      -- Update input_end_line
  1   self.input_end_line = self.input_start_line + 1
      
  1   if config.get('debug') then
**0     vim.notify("[ChatBuffer] Cleared input area", vim.log.levels.DEBUG)
      end
    end

    --- Set input area text
    -- @param text string: Text to set in input area
 26 function ChatBuffer:set_input(text)
      -- Build input section with text
**0   local input_lines = {
        "--- (<C-CR> to send) ---",
        text,
      }
      
      -- Replace input section
**0   vim.api.nvim_buf_set_lines(
**0     self.bufnr,
**0     self.input_start_line,
**0     self.input_end_line + 1,
        false,
        input_lines
      )
      
      -- Update input_end_line
**0   self.input_end_line = self.input_start_line + 1
      
**0   if config.get('debug') then
**0     vim.notify("[ChatBuffer] Set input text: " .. text, vim.log.levels.DEBUG)
      end
    end

    --- Focus cursor on input area
 26 function ChatBuffer:focus_input()
      -- Move cursor to input area (first editable line)
 21   local input_line = self.input_start_line + 2 -- Line after start marker
 21   vim.api.nvim_win_set_cursor(0, { input_line, 2 }) -- Position after "│ "
      
      -- Switch to insert mode
 21   vim.cmd('startinsert')
    end

    --- Check if cursor is in input area
    -- @return boolean: True if cursor is in input section
 26 function ChatBuffer:is_cursor_in_input()
**0   local cursor = vim.api.nvim_win_get_cursor(0)
**0   local line = cursor[1]
**0   return line > self.input_start_line and line <= self.input_end_line
    end

    --- Get buffer number
    -- @return number: Buffer number
 26 function ChatBuffer:get_bufnr()
 52   return self.bufnr
    end

 26 M.ChatBuffer = ChatBuffer
 26 return M

==============================================================================
lua/llm/chat/session.lua
==============================================================================
    -- llm/chat/session.lua - Chat Session Management
    -- License: Apache 2.0

 26 local M = {}
 26 local config = require('llm.config')
 26 local shell = require('llm.core.utils.shell')

    --- ChatSession class for managing individual chat sessions
    -- @class ChatSession
 26 local ChatSession = {}
 26 ChatSession.__index = ChatSession

    --- Create a new chat session
    -- @param opts table: Session options
    --   - model: string (optional) - Model to use
    --   - system_prompt: string (optional) - System prompt
    --   - fragments: table (optional) - List of fragment paths
    --   - bufnr: number (optional) - Associated buffer number
    -- @return ChatSession: New session instance
 26 function ChatSession.new(opts)
 18   opts = opts or {}
      
 18   local session = {
 18     conversation_id = nil,  -- Will be set after first response
 18     model = opts.model or config.get("model"),
 18     system_prompt = opts.system_prompt or config.get("system_prompt"),
 18     fragments = opts.fragments or {},
 18     bufnr = opts.bufnr,
 18     state = 'ready', -- ready, processing, error
 18     current_job_id = nil,
      }
      
 18   setmetatable(session, ChatSession)
      
 18   if config.get('debug') then
**0     vim.notify(
**0       string.format("[ChatSession] Created new session (model: %s)", session.model or "default"),
**0       vim.log.levels.DEBUG
        )
      end
      
 18   return session
    end

    --- Build command parts for llm CLI
    -- @param prompt string: User prompt to send
    -- @return table: Command parts array
 26 function ChatSession:build_command(prompt)
  4   local llm_executable = config.get("llm_executable_path") or "llm"
  4   local cmd_parts = { llm_executable, "prompt" }
      
      -- Add model if specified
  4   if self.model and self.model ~= "" then
  4     table.insert(cmd_parts, "-m")
  4     table.insert(cmd_parts, self.model)
      end
      
      -- For first message: add system prompt and fragments
      -- For continuation: use -c flag (system prompt and fragments are preserved)
  4   if not self.conversation_id then
        -- First message in conversation
  3     if self.system_prompt and self.system_prompt ~= "" then
  3       table.insert(cmd_parts, "-s")
  3       table.insert(cmd_parts, self.system_prompt)
        end
        
        -- Add fragments
  3     for _, fragment in ipairs(self.fragments) do
**0       table.insert(cmd_parts, "-f")
**0       table.insert(cmd_parts, fragment)
        end
      else
        -- Continuation of existing conversation
  1     table.insert(cmd_parts, "-c")
  1     table.insert(cmd_parts, self.conversation_id)
      end
      
      -- Note: Don't add prompt as argument here
      -- We'll send it via stdin to avoid quoting issues
      
  4   if config.get('debug') then
**0     vim.notify(
**0       string.format("[ChatSession] Command: %s (prompt via stdin)", table.concat(cmd_parts, " ")),
**0       vim.log.levels.DEBUG
        )
      end
      
  4   return cmd_parts
    end

    --- Extract conversation ID from LLM output
    -- The LLM CLI includes conversation ID in the output like:
    -- "Conversation ID: 01abc123def"
    -- @param output string: Output text from LLM
    -- @return string|nil: Extracted conversation ID or nil
 26 function ChatSession:extract_conversation_id(output)
  1   if not output or output == "" then
**0     return nil
      end
      
      -- Try to find conversation ID in the output
      -- Pattern: "Conversation ID: <id>"
  1   local id = output:match("Conversation ID: ([%w]+)")
      
  1   if id then
  1     if config.get('debug') then
**0       vim.notify(
**0         string.format("[ChatSession] Extracted conversation ID: %s", id),
**0         vim.log.levels.DEBUG
          )
        end
  1     return id
      end
      
**0   return nil
    end

    --- Get conversation ID from llm CLI logs
    -- Falls back to querying llm logs if ID not in output
    -- @return string|nil: Conversation ID or nil
 26 function ChatSession:get_conversation_id_from_logs()
**0   local llm_executable = config.get("llm_executable_path") or "llm"
**0   local cmd_string = string.format("%s logs -n 1 --json", llm_executable)
      
**0   local result = vim.fn.system(cmd_string)
      
**0   if not result or result == "" then
**0     if config.get('debug') then
**0       vim.notify("[ChatSession] No logs returned from llm CLI", vim.log.levels.DEBUG)
        end
**0     return nil
      end
      
      -- Trim whitespace
**0   result = result:gsub("^%s*(.-)%s*$", "%1")
      
      -- Parse JSON
**0   local ok, log_data = pcall(vim.json.decode, result)
**0   if not ok or not log_data or type(log_data) ~= "table" or #log_data == 0 then
**0     if config.get('debug') then
**0       vim.notify("[ChatSession] Failed to parse llm logs JSON", vim.log.levels.DEBUG)
        end
**0     return nil
      end
      
      -- Get conversation ID from first log entry
**0   local conversation_id = log_data[1] and log_data[1].conversation_id
      
**0   if conversation_id then
**0     if config.get('debug') then
**0       vim.notify(
**0         string.format("[ChatSession] Got conversation ID from logs: %s", conversation_id),
**0         vim.log.levels.DEBUG
          )
        end
      end
      
**0   return conversation_id
    end

    --- Update conversation ID from output or logs
    -- @param output string: LLM output text
 26 function ChatSession:update_conversation_id(output)
      -- First try to extract from output
**0   local id = self:extract_conversation_id(output)
      
      -- If not in output, query logs
**0   if not id then
**0     id = self:get_conversation_id_from_logs()
      end
      
**0   if id then
**0     self.conversation_id = id
**0     if config.get('debug') then
**0       vim.notify(
**0         string.format("[ChatSession] Conversation ID updated: %s", id),
**0         vim.log.levels.DEBUG
          )
        end
      else
**0     if config.get('debug') then
**0       vim.notify("[ChatSession] Could not determine conversation ID", vim.log.levels.WARN)
        end
      end
    end

    --- Send a prompt to the LLM
    -- @param prompt string: User prompt
    -- @param callbacks table: Callbacks for streaming
    --   - on_stdout: function(job_id, data) - Called with stdout chunks
    --   - on_stderr: function(job_id, data) - Called with stderr chunks
    --   - on_exit: function(job_id, exit_code) - Called on completion
    -- @return number|nil: Job ID or nil if failed
 26 function ChatSession:send_prompt(prompt, callbacks)
  2   if not prompt or prompt == "" then
**0     vim.notify("Cannot send empty prompt", vim.log.levels.ERROR)
**0     return nil
      end
      
      -- Build command
  2   local cmd_parts = self:build_command(prompt)
      
      -- Update state
  2   self.state = 'processing'
      
      -- Track accumulated output for conversation ID extraction
  2   local accumulated_output = ""
      
      -- Wrap callbacks to track output and update conversation ID
  2   local wrapped_callbacks = {
        on_stdout = function(job_id, data)
**0       if data then
**0         for _, line in ipairs(data) do
**0           accumulated_output = accumulated_output .. line .. "\n"
            end
          end
          
**0       if callbacks and callbacks.on_stdout then
**0         callbacks.on_stdout(job_id, data)
          end
        end,
        
        on_stderr = function(job_id, data)
**0       if callbacks and callbacks.on_stderr then
**0         callbacks.on_stderr(job_id, data)
          end
        end,
        
        on_exit = function(job_id, exit_code)
          -- Update conversation ID after first message
**0       if not self.conversation_id then
**0         self:update_conversation_id(accumulated_output)
          end
          
          -- Update state
**0       if exit_code == 0 then
**0         self.state = 'ready'
          else
**0         self.state = 'error'
          end
          
**0       self.current_job_id = nil
          
**0       if callbacks and callbacks.on_exit then
**0         callbacks.on_exit(job_id, exit_code)
          end
        end,
      }
      
      -- Execute command using job module
  2   local job = require('llm.core.utils.job')
  2   local job_id = job.run(cmd_parts, wrapped_callbacks)
      
  2   if job_id then
  2     self.current_job_id = job_id
        
        -- Send prompt via stdin to avoid shell quoting issues
  2     vim.fn.chansend(job_id, prompt)
  2     vim.fn.chanclose(job_id, "stdin")
        
  2     if config.get('debug') then
**0       vim.notify(
**0         string.format("[ChatSession] Started job %d, sent prompt: %s", job_id, prompt),
**0         vim.log.levels.DEBUG
          )
        end
      else
**0     self.state = 'error'
**0     vim.notify("Failed to start LLM command", vim.log.levels.ERROR)
      end
      
  2   return job_id
    end

    --- Get current conversation ID
    -- @return string|nil: Conversation ID or nil
 26 function ChatSession:get_conversation_id()
**0   return self.conversation_id
    end

    --- Get current session state
    -- @return string: Session state (ready, processing, error)
 26 function ChatSession:get_state()
**0   return self.state
    end

    --- Check if session is ready for new prompts
    -- @return boolean: True if ready
 26 function ChatSession:is_ready()
  6   return self.state == 'ready'
    end

    --- Stop current job if running
 26 function ChatSession:stop_current_job()
**0   if self.current_job_id then
**0     vim.fn.jobstop(self.current_job_id)
**0     self.current_job_id = nil
**0     self.state = 'ready'
        
**0     if config.get('debug') then
**0       vim.notify("[ChatSession] Stopped current job", vim.log.levels.DEBUG)
        end
      end
    end

 26 M.ChatSession = ChatSession
 26 return M

==============================================================================
lua/llm/commands.lua
==============================================================================
    -- llm/commands.lua - Command execution for llm-nvim
    -- License: Apache 2.0

  6 local M = {}

    -- Forward declarations
  6 local nvim_api = vim.api
  6 local api = require('llm.api')
  6 local config = require('llm.config')
  6 local ui = require('llm.core.utils.ui')
  6 local text = require('llm.core.utils.text')
  6 local shell = require('llm.core.utils.shell')
  6 local llm_cli = require('llm.core.data.llm_cli')
  6 local job = require('llm.core.utils.job')

    ---------------------
    -- Helper Functions
    ---------------------

    -- Get the configured llm executable path
  6 function M.get_llm_executable_path()
  3   return config.get("llm_executable_path")
    end

    -- Get the model argument if specified
  6 function M.get_model_arg()
  3   local model = config.get("model")
  3   if model and model ~= "" then
        -- Return as a table element for later concatenation
  3     return { "-m", model }
      end
**0   return {} -- Return empty table if no model
    end

    -- Get the system prompt argument if specified
  6 function M.get_system_arg()
  3   local system = config.get("system_prompt")
  3   if system and system ~= "" then
        -- Return as a table element for later concatenation
  3     return { "-s", system }
      end
**0   return {} -- Return empty table if no system prompt
    end

    -- Get fragment arguments if specified
  6 function M.get_fragment_args(fragment_list)
  3   if not fragment_list or #fragment_list == 0 then
  3     return {} -- Return empty table if no fragments
      end

**0   local args = {}
**0   for _, fragment in ipairs(fragment_list) do
        -- Add '-f' and the fragment as separate elements
**0     table.insert(args, "-f")
**0     table.insert(args, fragment)

        -- Debug output
**0     local config = require('llm.config')
**0     if config.get('debug') then
**0       vim.notify("Adding fragment: " .. fragment, vim.log.levels.DEBUG)
        end
      end

**0   return args -- Return the table directly
    end

    -- Get system fragment arguments if specified
  6 function M.get_system_fragment_args(fragment_list)
**0   if not fragment_list or #fragment_list == 0 then
**0     return {} -- Return empty table if no fragments
      end

**0   local args = {}
**0   for _, fragment in ipairs(fragment_list) do
        -- Add '--system-fragment' and the fragment as separate elements
**0     table.insert(args, "--system-fragment")
**0     table.insert(args, fragment)
      end

**0   return args -- Return the table directly
    end

    -- Run an llm command and return the result

  6 function M.get_pre_response_message(source, prompt, fragment_paths)
**0   local message_parts = {}

**0   table.insert(message_parts, "Passing your prompt to llm tool")
**0   table.insert(message_parts, " ")
**0   table.insert(message_parts, "---")
**0   table.insert(message_parts, " ")
**0   table.insert(message_parts, "Prompt: " .. prompt)
**0   table.insert(message_parts, "Source: " .. source)
**0   if fragment_paths and #fragment_paths > 0 then
**0     table.insert(message_parts, "Fragments: " .. table.concat(fragment_paths, ", "))
      end
**0   table.insert(message_parts, " ")
**0   table.insert(message_parts, "---")
**0   table.insert(message_parts, " ")
**0   table.insert(message_parts, "Processing, please wait...")
**0   table.insert(message_parts, " ")
**0   table.insert(message_parts, "(Note that results will be written to this buffer)")

**0   return table.concat(message_parts, "\n")
    end

  6 function M.write_context_to_temp_file(context)
**0   local temp_file = os.tmpname()
**0   local file = io.open(temp_file, "w")
**0   if not file then
**0     api.nvim_err_writeln("Failed to create temporary file")
**0     return ""
      end

**0   file:write(context)
**0   file:close()

**0   return temp_file
    end

  6 function M.create_response_buffer(content)
**0   ui.create_buffer_with_content(content, "LLM Response", "markdown")
    end

  6 function M.fill_response_buffer(bufnr, content)
**0   ui.replace_buffer_with_content(content, bufnr, "markdown")
**0   vim.cmd("redraw")
    end

    -- Helper function to select an existing fragment alias
    local function select_existing_fragment(callback)
**0   local fragments_manager = require('llm.managers.fragments_manager')
**0   local existing_fragments = fragments_manager.get_fragments() -- Get fragments with aliases

**0   if not existing_fragments or #existing_fragments == 0 then
**0     vim.notify("No existing fragments with aliases found.", vim.log.levels.WARN)
**0     callback(nil) -- Indicate no selection
**0     return
      end

**0   local items = {}
**0   local fragment_map = {}
**0   for i, frag in ipairs(existing_fragments) do
**0     local display_name = (#frag.aliases > 0 and frag.aliases[1] or frag.hash:sub(1, 8)) ..
**0         " (" .. (frag.source or "hash") .. ")"
**0     table.insert(items, display_name)
**0     fragment_map[i] = (#frag.aliases > 0 and frag.aliases[1] or frag.hash) -- Store identifier (prefer alias)
      end

**0   vim.ui.select(items, {
        prompt = "Select an existing fragment:",
**0     format_item = function(item) return item end
      }, function(choice, idx)
**0     if not choice then
**0       callback(nil)
**0       return
        end
**0     local identifier = fragment_map[idx]
**0     callback(identifier)
      end)
    end

    ---------------------
    -- LLM Prompt Commands
    ---------------------

    -- Unified command dispatcher
  6 function M.dispatch_command(subcmd, ...)
**0   local args = { ... }
**0   local success, err = pcall(function()
**0     if subcmd == "selection" then
**0       return M.prompt_with_selection(args[1] or "", args[2] or {})
**0     elseif subcmd == "toggle" then
**0       local unified_manager = require('llm.ui.unified_manager')
**0       return unified_manager.toggle(args[1] or "")
**0     elseif subcmd == "" then
**0       return ui.create_prompt_buffer()
        else
          -- Default case: treat as direct prompt
**0       return M.prompt(subcmd, args[1] or {})
        end
      end)

**0   if not success then
**0     vim.notify("Error dispatching command: " .. tostring(err), vim.log.levels.ERROR)
      end
    end

    -- Send a prompt to llm
  6 function M.prompt(prompt, fragment_paths, bufnr)
  3   local llm_executable_path = config.get("llm_executable_path")
  3   local model = config.get("model")
  3   local system_prompt = config.get("system_prompt")

  3   local cmd_parts = { llm_executable_path }

  3   if model and model ~= "" then
  3     table.insert(cmd_parts, "-m")
  3     table.insert(cmd_parts, model)
      end

  3   if system_prompt and system_prompt ~= "" then
  2     table.insert(cmd_parts, "-s")
  2     table.insert(cmd_parts, system_prompt)
      end

  3   if fragment_paths then
  2     for _, fragment in ipairs(fragment_paths) do
**0       table.insert(cmd_parts, "-f")
**0       table.insert(cmd_parts, fragment)
        end
      end

  3   local target_bufnr = bufnr
  3   if not target_bufnr then
  1     vim.cmd('vnew')
  1     target_bufnr = vim.api.nvim_get_current_buf()
  1     local buffer_name = "LLM Response - " .. os.time()
  1     vim.api.nvim_buf_set_name(target_bufnr, buffer_name)
  1     vim.api.nvim_buf_set_option(target_bufnr, 'filetype', 'markdown')
  1     vim.api.nvim_buf_set_lines(target_bufnr, 0, -1, false, { "Waiting for response..." })
      end

  3   local callbacks = {
        on_stdout = function(_, data) 
  1       if data then
  2         for _, line in ipairs(data) do
  1           ui.append_to_buffer(target_bufnr, line .. "\n", "LlmModelResponse")
            end
          end
        end,
      }

  3   api.run_streaming_command(cmd_parts, prompt, callbacks)
    end



    -- Explain the current buffer or selection
  6 function M.explain_code(fragment_paths, bufnr)
**0   M.prompt_with_current_file("Explain this code", fragment_paths, bufnr)
    end

  6 function M.prompt_with_current_file(prompt, fragment_paths, bufnr)
  2   local filepath = vim.fn.expand('%:p')
  2   if filepath == "" then
**0     vim.notify("Current buffer has no file path", vim.log.levels.ERROR)
**0     return
      end

  2   local cmd_parts = { M.get_llm_executable_path() }

      -- Add model and system args
  2   vim.list_extend(cmd_parts, M.get_model_arg())
  2   vim.list_extend(cmd_parts, M.get_system_arg())

      -- Add user-specified fragments
  2   if fragment_paths then
  2     vim.list_extend(cmd_parts, M.get_fragment_args(fragment_paths))
      end

      -- Add the current file as a fragment
  2   table.insert(cmd_parts, "-f")
  2   table.insert(cmd_parts, filepath)

  2   local target_bufnr = bufnr
  2   if not target_bufnr then
**0     vim.cmd('vnew')
**0     target_bufnr = vim.api.nvim_get_current_buf()
**0     local buffer_name = "LLM Response - " .. os.time()
**0     vim.api.nvim_buf_set_name(target_bufnr, buffer_name)
**0     vim.api.nvim_buf_set_option(target_bufnr, 'filetype', 'markdown')
**0     vim.api.nvim_buf_set_lines(target_bufnr, 0, -1, false, { "Waiting for response..." })
      end

  2   local callbacks = {
        on_stdout = function(_, data) 
  1       if data then
  2         for _, line in ipairs(data) do
  1           ui.append_to_buffer(target_bufnr, line .. "\n", "LlmModelResponse")
            end
          end
        end,
      }

  2   api.run_streaming_command(cmd_parts, prompt, callbacks)
    end



    -- Send selected text with a prompt to llm
  6 function M.prompt_with_selection(prompt, fragment_paths, from_visual_mode, bufnr)
      local selection
  1   if from_visual_mode then
  1     selection = text.get_visual_selection()
      else
**0     selection = vim.nvim_get_current_line()
      end

  1   if selection == "" then
**0     vim.notify("No text selected", vim.log.levels.WARN)
**0     return
      end

  1   local temp_file = M.write_context_to_temp_file(selection)

  1   local cmd_parts = { M.get_llm_executable_path() }
  1   vim.list_extend(cmd_parts, M.get_model_arg())
  1   vim.list_extend(cmd_parts, M.get_system_arg())
  1   if fragment_paths then
  1     vim.list_extend(cmd_parts, M.get_fragment_args(fragment_paths))
      end
  1   table.insert(cmd_parts, "-f")
  1   table.insert(cmd_parts, temp_file)
  1   local target_bufnr = bufnr
  1   if not target_bufnr then
**0     vim.cmd('vnew')
**0     target_bufnr = vim.api.nvim_get_current_buf()
**0     local buffer_name = "LLM Response - " .. os.time()
**0     vim.api.nvim_buf_set_name(target_bufnr, buffer_name)
**0     vim.api.nvim_buf_set_option(target_bufnr, 'filetype', 'markdown')
**0     vim.api.nvim_buf_set_lines(target_bufnr, 0, -1, false, { "Waiting for response..." })
      end

  1   local callbacks = {
        on_stdout = function(_, data) 
**0       if data then
**0         for _, line in ipairs(data) do
**0           ui.append_to_buffer(target_bufnr, line .. "\n", "LlmModelResponse")
            end
          end
        end,
        on_exit = function()
  1       vim.notify("LLM command finished.")
          -- Clean up the temporary file
  1       os.remove(temp_file)
        end,
      }

  1   api.run_streaming_command(cmd_parts, prompt, callbacks)
    end


    ---------------------
    -- Interactive Commands
    ---------------------

    -- Interactive prompt allowing selection of multiple fragments
    -- NOTE: This function is not fully tested due to the complexity of mocking the interactive UI.
  6 function M.interactive_prompt_with_fragments(opts)
**0   opts = opts or {}
**0   local fragments_manager = require('llm.managers.fragments_manager') -- Load here to avoid circular dependency issues at top level
**0   local fragments_list = {}
      local visual_selection_text = nil
      local visual_selection_temp_file = nil

      -- Check for visual selection
**0   if opts.range and opts.range > 0 then
**0     visual_selection_text = text.get_visual_selection()
**0     if visual_selection_text and visual_selection_text ~= "" then
          -- Save selection to a temporary file to treat it like a fragment source
**0       visual_selection_temp_file = os.tmpname()
**0       local file = io.open(visual_selection_temp_file, "w")
**0       if file then
**0         file:write(visual_selection_text)
**0         file:close()
**0         table.insert(fragments_list, visual_selection_temp_file)
**0         vim.notify("Added visual selection as fragment source.", vim.log.levels.INFO)
          else
**0         vim.notify("Failed to create temporary file for visual selection.", vim.log.levels.ERROR)
**0         visual_selection_temp_file = nil -- Ensure it's nil if creation failed
          end
        else
**0       visual_selection_text = nil -- Reset if selection was empty
        end
      end

      local function add_more_fragments()
**0     local options = {
          "Select existing fragment (alias/hash)",
          "Select file as fragment",
          "Enter fragment path/URL",
          "Use GitHub repository",
          "Done - continue with prompt"
        }

**0     vim.ui.select(options, {
**0       prompt = "Add fragments to prompt (" .. #fragments_list .. " added):"
        }, function(choice)
**0       if not choice then return end -- User cancelled selection loop

          local function handle_fragment_added(identifier)
**0         if identifier then
              -- Avoid adding duplicates
**0           local found = false
**0           for _, existing in ipairs(fragments_list) do
**0             if existing == identifier then
**0               found = true
                  break
                end
              end
**0           if not found then
**0             table.insert(fragments_list, identifier)
**0             vim.notify("Added fragment: " .. identifier, vim.log.levels.INFO)
              else
**0             vim.notify("Fragment already added: " .. identifier, vim.log.levels.WARN)
              end
            end
**0         vim.schedule(add_more_fragments) -- Continue the loop
          end

**0       if choice == "Select existing fragment (alias/hash)" then
**0         select_existing_fragment(handle_fragment_added)
**0       elseif choice == "Select file as fragment" then
**0         fragments_manager.add_file_fragment(nil)
**0       elseif choice == "Enter fragment path/URL" then
**0         vim.ui.input({ prompt = "Enter fragment path/URL: " }, function(input)
**0           if input and input ~= "" then
**0             handle_fragment_added(input)
              else
**0             add_more_fragments() -- Re-prompt if input is empty
              end
            end)
**0       elseif choice == "Use GitHub repository" then
**0         fragments_manager.add_github_fragment_from_manager(nil)
**0       elseif choice == "Done - continue with prompt" then
**0         if #fragments_list == 0 then
**0           vim.notify("No fragments selected.", vim.log.levels.WARN)
**0           return -- Exit if no fragments
            end

            -- Now ask for the prompt
**0         vim.ui.input({
**0           prompt = "Enter prompt: "
            }, function(input_prompt)
**0           if not input_prompt or input_prompt == "" then
**0             vim.notify("Prompt cannot be empty.", vim.log.levels.ERROR)
                -- Clean up temp file if prompt is cancelled
**0             if visual_selection_temp_file then os.remove(visual_selection_temp_file) end
**0             return
              end

              -- Decide which command to call based on whether visual selection was the *only* input
              -- Note: We currently always use M.prompt and pass the temp file path if visual selection was used.
              -- A potential enhancement is to detect if *only* the visual selection temp file is present
              -- and call M.prompt_with_selection directly with the text, but this adds complexity.
              -- For now, using the temp file path in M.prompt is simpler.

**0           M.prompt(input_prompt, fragments_list)

              -- Clean up temp file *after* the command runs (or is supposed to run)
              -- Using defer_fn to ensure it runs after the current execution context
**0           if visual_selection_temp_file then
**0             vim.defer_fn(function() os.remove(visual_selection_temp_file) end, 100)
              end
            end)
          else
**0         add_more_fragments() -- Should not happen, but ensures loop continues
          end
        end)
      end

      -- Start the fragment selection loop
**0   add_more_fragments()
    end

    -- Test function to verify terminal creation
  6 function M.test_terminal_creation()
**0   vim.notify("Testing terminal creation...", vim.log.levels.INFO)
**0   vim.cmd('new')
**0   local buf = vim.api.nvim_get_current_buf()
**0   vim.notify("Created buffer: " .. buf, vim.log.levels.INFO)

**0   local cmd = "echo 'Test terminal'"
**0   vim.notify("Executing: terminal " .. cmd, vim.log.levels.INFO)
**0   vim.cmd('terminal ' .. cmd)

**0   local term_buf = vim.api.nvim_get_current_buf()
**0   vim.notify("Terminal buffer: " .. term_buf, vim.log.levels.INFO)
**0   local buf_type = vim.api.nvim_buf_get_option(term_buf, 'buftype')
**0   vim.notify("Buffer type: " .. buf_type, vim.log.levels.INFO)

**0   vim.cmd('startinsert')
    end

  6 return M

==============================================================================
lua/llm/config.lua
==============================================================================
    -- llm/config.lua - Centralized Configuration Management
    -- License: Apache 2.0

 22 local M = {}
 22 local listeners = {}
 22 local validate = require('llm.core.utils.validate')

    -- Default configuration with metadata
 22 M.defaults = {
 22   model = {
 22     default = nil,
 22     type = "string",
 22     desc = "Default model to use (falls back to llm CLI default)"
 22   },
 22   system_prompt = {
 22     default = "You are a helpful assistant.",
 22     type = "string",
 22     desc = "Default system prompt for all queries"
 22   },
 22   no_mappings = {
 22     default = false,
 22     type = "boolean",
 22     desc = "Disable default key mappings"
 22   },
 22   debug = {
 22     default = false,
 22     type = "boolean",
 22     desc = "Enable debug logging"
 22   },
 22   auto_update_cli = {
 22     default = false,
 22     type = "boolean",
 22     desc = "Enable or disable auto-updates for the LLM CLI"
 22   },
 22   auto_update_interval_days = {
 22     default = 7,
 22     type = "number",
 22     desc = "Interval in days for checking for updates"
 22   },
 22   llm_executable_path = {
 22     default = "llm",
 22     type = "string",
 22     desc = "Path to the llm executable (e.g., 'llm' or '/usr/local/bin/llm')"
 22   },
      -- Add more config options here
 22 }

    -- Current configuration
 22 M.options = {}

    -- Validate and normalize configuration
    local function process_config(opts)
 28   local processed = {}
 42   for k, v in pairs(opts) do
 14     if M.defaults[k] then
          -- Type checking
 14       if type(v) ~= M.defaults[k].type then
**0         v = validate.convert(v, M.defaults[k].type)
          end
          -- Ensure proper structure
 14       if type(v) == 'table' and v.value ~= nil then
**0         processed[k] = v
          else
 14         processed[k] = {value = v}
          end
        else
**0       require('llm.errors').handle('config',
**0         "Ignoring unknown config option: "..k, nil, 'warning')
        end
      end
 28   return processed
    end

    -- Initialize configuration
 22 function M.setup(opts)
 28   opts = opts or {}

      -- Process and validate new config
 28   local new_config = process_config(opts)

      -- Merge with defaults
 28   M.options = vim.tbl_deep_extend("force", {}, M.defaults, new_config)

      -- Notify listeners
 29   for _, listener in ipairs(listeners) do
  1     listener(M.options)
      end
    end

    -- Get configuration value(s)
 22 function M.get(key)
 64   if not key then
        -- Return a deepcopy of all *actual* values, not the internal structure
  1     local current_values = {}
  8     for k_option, _ in pairs(M.options) do
  7       current_values[k_option] = M.get(k_option) -- Recursively call M.get for each key
        end
  1     return current_values
      end

 63   local option_entry = M.options[key]
 63   if option_entry == nil then
        -- This case should ideally be caught by M.defaults having all valid keys
        -- or process_config filtering unknown keys.
        -- If an unknown key is passed, returning nil is appropriate.
 48     return nil
      end

 15   if type(option_entry) == 'table' then
 15     if option_entry.value ~= nil then
  7       return option_entry.value -- User-set value
  8     elseif option_entry.default ~= nil then
  7       return option_entry.default -- Default value from M.defaults
        end
      end
      -- This case should ideally not be reached if options are always tables
      -- from M.defaults or {value=...} from user config.
      -- However, returning option_entry directly might be a fallback for unforeseen structures
      -- or if M.options contains direct values not conforming to {value=...} or {default=...}.
      -- For robustness, if it's not a table with 'value' or 'default', but the key exists,
      -- it might be a direct value (though current setup logic aims to wrap these).
      -- If it's a table but doesn't have .value or .default (e.g. just {type="...", desc="..."}),
      -- then it implies no value is set and no default value exists, so nil is appropriate.
  1   if type(option_entry) == 'table' and option_entry.value == nil and option_entry.default == nil then
  1     return nil -- No user-set value and no default value defined for this key
      end
**0   return option_entry -- Fallback for direct values or unexpected structures
    end

    -- Register config change listener
 22 function M.on_change(fn)
  1   table.insert(listeners, fn)
      return function() -- returns unregister function
**0     for i, listener in ipairs(listeners) do
**0       if listener == fn then
**0         table.remove(listeners, i)
            break
          end
        end
      end
    end

    -- Reset to defaults
 22 function M.reset()
  1   local defaults = {}
  8   for k, v in pairs(M.defaults) do
  7     defaults[k] = v.default
      end
  1   M.setup(defaults)
    end

    -- Initialize with empty config
 22 M.setup({})

 22 return M

==============================================================================
lua/llm/core/data/cache.lua
==============================================================================
    -- llm/core/data/cache.lua - Caching for llm-nvim
    -- License: Apache 2.0

 12 local M = {}

 12 local cache_file_path = vim.fn.stdpath('cache') .. '/llm_nvim_cache.json'
 12 local cache = {}

    -- Load cache from file
    local function load_cache()
 12   local file = io.open(cache_file_path, "r")
 12   if file then
  6     local content = file:read("*all")
  6     file:close()
  6     local ok, decoded = pcall(vim.fn.json_decode, content)
  6     if ok and type(decoded) == 'table' then
  6       cache = decoded
        else
          -- If decoding fails, initialize an empty cache
**0       cache = {}
        end
      else
  6     cache = {}
      end
    end

    -- Save cache to file
    local function save_cache()
 53   local encoded = vim.fn.json_encode(cache)
 53   local file = io.open(cache_file_path, "w")
 53   if file then
  8     file:write(encoded)
  8     file:close()
      end
    end

    -- Initialize cache on module load
 12 load_cache()

 12 function M.get(key)
 17   return cache[key]
    end

 12 function M.set(key, value)
 14   cache[key] = value
 14   save_cache()
    end

 12 function M.invalidate(key)
 39   cache[key] = nil
 39   save_cache()
    end

 12 return M

==============================================================================
lua/llm/core/data/llm_cli.lua
==============================================================================
    -- llm/core/data/llm_cli.lua - LLM CLI interaction
    -- License: Apache 2.0

 18 local M = {}

 18 local shell = require('llm.core.utils.shell')
 18 local api = require('llm.api') -- Added for streaming

 18 function M.run_llm_command(command, bufnr)
 16     local full_command_parts = vim.split('llm ' .. command, ' ')

 16     if bufnr then
**0         return api.run_llm_command_streamed(full_command_parts, bufnr)
        else
 16         return shell.safe_shell_command(table.concat(full_command_parts, ' '))
        end
    end

 18 return M

==============================================================================
lua/llm/core/loaders.lua
==============================================================================
    -- llm/core/loaders.lua - Data loaders for llm-nvim
    -- License: Apache 2.0

 12 local M = {}

 12 local llm_cli = require('llm.core.data.llm_cli')
 12 local cache = require('llm.core.data.cache')

 12 function M.load_models()
      
  4   local models_output = llm_cli.run_llm_command('models list')
      
  4   if models_output then
  4     local models = {}
 12     for line in models_output:gmatch("[^\n]+") do
  8       if not line:match("^%-%-") and line ~= "" and not line:match("^Models:") and not line:match("^Default:") then
  8         local provider, model_id = line:match("([^:]+): (.*)")
  8         if provider and model_id then
  4           table.insert(models, { provider = provider, id = model_id, name = model_id })
            end
          end
        end
  4     cache.set('models', models)
      end
      
    end

 12 function M.load_available_plugins()
      
  4   local plugins_output = llm_cli.run_llm_command('plugins --all')
      
  4   if plugins_output then
  4     local plugins = {}
 12     for line in plugins_output:gmatch("[^\n]+") do
  8       local plugin_name, description = line:match("^(%S+)%s*-%s*(.*)")
  8       if plugin_name and description then
  8         table.insert(plugins, { name = plugin_name, description = description })
          end
        end
  4     cache.set('available_plugins', plugins)
      end
      
    end

 12 function M.load_keys()
      
  4   local keys_output = llm_cli.run_llm_command('keys list')
      
  4   if keys_output then
  4     local keys = {}
 16     for line in keys_output:gmatch("[^\n]+") do
 12       if line ~= "Stored keys:" and line ~= "------------------" and line ~= "" then
  8         table.insert(keys, { name = line })
          end
        end
  4     cache.set('keys', keys)
      end
      
    end

 12 function M.load_fragments()
      
  4   local fragments_output = llm_cli.run_llm_command('fragments list')
      
  4   if fragments_output then
  4     local fragments = {}
  4     local current_fragment = nil
 30     for line in fragments_output:gmatch("[^\n]+") do
 26       local hash = line:match("^%s*-%s+hash:%s+([0-9a-f]+)")
 26       if hash then
  4         if current_fragment then
  2           table.insert(fragments, current_fragment)
            end
  4         current_fragment = { hash = hash, aliases = {}, source = "", content = "", datetime = "" }
          else
 22         if current_fragment then
 18           local alias = line:match("^%s+-%s+(.+)")
 18           if alias then
  6             table.insert(current_fragment.aliases, alias)
              end
 18           local source = line:match("^%s+source:%s+(.+)")
 18           if source then
  4             current_fragment.source = source
              end
 18           local content = line:match("^%s+content:%s+(.+)")
 18           if content then
  4             current_fragment.content = content
              end
 18           local datetime = line:match("^%s+datetime:%s+(.+)")
 18           if datetime then
  4             current_fragment.datetime = datetime
              end
            end
          end
        end
  4     if current_fragment then
  2       table.insert(fragments, current_fragment)
        end
  4     cache.set('fragments', fragments)
      end
      
    end

 12 function M.load_templates()
      
  4   local templates_output = llm_cli.run_llm_command('templates list')
      
  4   if templates_output then
  4     local templates = {}
 12     for line in templates_output:gmatch("[^\n]+") do
  8       local name, description = line:match("^(%S+)%s*-%s*(.*)")
  8       if name and description then
  8         table.insert(templates, { name = name, description = description })
          end
        end
  4     cache.set('templates', templates)
      end
      
    end

 12 function M.load_schemas()
      
  4   local schemas_output = llm_cli.run_llm_command('schemas list')
      
  4   if schemas_output then
  4     local schemas = {}
 12     for line in schemas_output:gmatch("[^\n]+") do
  8       local id, description = line:match("^(%S+)%s*-%s*(.*)")
  8       if id and description then
  8         table.insert(schemas, { id = id, description = description })
          end
        end
  4     cache.set('schemas', schemas)
      end
      
    end

 12 function M.load_all()
  2   M.load_models()
  2   M.load_available_plugins()
  2   M.load_keys()
  2   M.load_fragments()
  2   M.load_templates()
  2   M.load_schemas()
    end

 12 return M

==============================================================================
lua/llm/core/utils/file_utils.lua
==============================================================================
 23 local M = {}

 23 local config = require('llm.config')
 23 local shell = require('llm.core.utils.shell')

 23 function M.set_shell(new_shell)
  8   shell = new_shell
    end

    -- Pure path utilities --------------------------------------------------------

    local function trim_path(path)
 12   return path and path:gsub("[\r\n]+$", ""):gsub("%s+$", "") or nil
    end

    local function join_path(dir, file)
  4   return dir and file and dir .. "/" .. file or nil
    end

    local function debug_log(message, level)
 10   if config.get('debug') then
**0     vim.notify(message, level or vim.log.levels.DEBUG)
      end
    end

    -- Directory operations -------------------------------------------------------

 23 local config_dir_cache = nil

    local function with_directory(dir, action)
**0   if not dir or dir == "" then return false end

**0   local test_file = join_path(dir, ".llm_nvim_test")
**0   local success, err = pcall(function()
**0     local f = io.open(test_file, "a")
**0     if not f then return false end
**0     f:close()

**0     if action == "test" then
**0       os.remove(test_file)
**0       return true
**0     elseif action == "create" then
**0       local mkdir_cmd = string.format("mkdir -p '%s'", dir)
**0       return os.execute(mkdir_cmd) == 0
        end
**0     return false
      end)

**0   return success and err ~= false
    end

 23 function M._test_directory_writable(dir)
**0   return with_directory(dir, "test")
    end

 23 function M._create_directory(dir)
**0   if with_directory(dir, "create") then
**0     debug_log("Created directory: " .. dir)
**0     return true
      else
**0     vim.notify("Failed to create directory: " .. dir, vim.log.levels.ERROR)
**0     return false
      end
    end

 23 function M.ensure_config_dir_exists(dir)
  6   return dir and (M._test_directory_writable(dir) or M._create_directory(dir))
    end

    -- Config path resolution -----------------------------------------------------

    local function resolve_config_dir()
 16   local logs_path = trim_path(shell.safe_shell_command(
  8     "llm logs path",
        "Failed to get LLM logs path"
  8   ))
  8   if not logs_path then return nil end

  4   debug_log("Found logs path: " .. logs_path)
  8   return trim_path(shell.safe_shell_command(
  4     string.format("dirname '%s'", logs_path),
        "Failed to get config directory"
  4   ))
    end

 23 function M.get_config_path(filename)
 12   if not filename then return nil, nil end

      -- Use cached config directory if available
 10   if config_dir_cache then
  2     local path = join_path(config_dir_cache, filename)
  2     debug_log("Using cached path: " .. path)
  2     return config_dir_cache, path
      end

      -- Resolve fresh config directory
  8   local config_dir = resolve_config_dir()
  8   if not config_dir then return nil, nil end

      -- Ensure directory exists and cache it
  4   if M.ensure_config_dir_exists(config_dir) then
  2     config_dir_cache = config_dir
  2     local path = join_path(config_dir, filename)

  2     debug_log("Final path: " .. path)
  2     debug_log("File " .. (io.open(path, "r") and "exists" or "does not exist"))
  2     return config_dir, path
      end

  2   return nil, nil
    end

 23 return M

==============================================================================
lua/llm/core/utils/job.lua
==============================================================================
 13 local M = {}

 13 function M.run(cmd, callbacks)
  3   local config = require('llm.config')
  3   if config.get('debug') then
**0     vim.notify("Starting job: " .. cmd[1], vim.log.levels.DEBUG)
      end

  3   local stdout_buffer = ""
  3   local stderr_buffer = ""

      local function process_output(data, event)
  4     if not data then return end

  4     local handler = (event == "stdout" and callbacks.on_stdout) or (event == "stderr" and callbacks.on_stderr)
  4     if not handler then return end
        
  4     local buffer = (event == "stdout") and stdout_buffer or stderr_buffer
        
  8     for _, chunk in ipairs(data) do
          -- Accumulate chunk into buffer
  4       buffer = buffer .. chunk
          
          -- Split buffer on newlines
  4       local lines = {}
          while true do
  8         local newline_pos = buffer:find('\n')
  8         if not newline_pos then break end
            
            -- Extract line without the newline
  4         local line = buffer:sub(1, newline_pos - 1)
  4         table.insert(lines, line)
            
            -- Remove processed line from buffer
  4         buffer = buffer:sub(newline_pos + 1)
          end
          
          -- Update the appropriate buffer
  4       if event == "stdout" then
  4         stdout_buffer = buffer
          else
**0         stderr_buffer = buffer
          end
          
          -- Call handler with complete lines
  4       if #lines > 0 then
  3         handler(nil, lines)
          end
        end
      end

  3   local options = {
        on_exit = function(j, exit_code)
**0       if config.get('debug') then
**0         vim.notify("Job exited with code: " .. tostring(exit_code), vim.log.levels.DEBUG)
          end
          
          -- Process any remaining buffered stdout before calling the final on_exit callback
**0       if #stdout_buffer > 0 then
**0         if callbacks.on_stdout then
**0           callbacks.on_stdout(nil, {stdout_buffer})
            end
**0         stdout_buffer = "" -- Clear buffer after processing
          end
          
          -- Process any remaining buffered stderr
**0       if #stderr_buffer > 0 then
**0         if callbacks.on_stderr then
**0           callbacks.on_stderr(nil, {stderr_buffer})
            end
**0         stderr_buffer = "" -- Clear buffer after processing
          end
          
**0       if callbacks.on_exit then callbacks.on_exit(j, exit_code) end
        end,
  7     on_stdout = function(j, d, e) process_output(d, e) end,
  3     on_stderr = function(j, d, e) process_output(d, e) end,
  3     stdout_buffered = false,
  3     stderr_buffered = false,
      }

  3   local job_id = vim.fn.jobstart(cmd, options)

  3   if not job_id or job_id <= 0 then
**0     vim.notify("Failed to start job: " .. cmd[1], vim.log.levels.ERROR)
**0     return nil
      else
  3     return job_id
      end
    end

 13 return M

==============================================================================
lua/llm/core/utils/notify.lua
==============================================================================
  8 local M = {}

  8 function M.notify(msg, level, opts)
  4   vim.notify(msg, level, opts or {})
    end

  8 return M

==============================================================================
lua/llm/core/utils/shell.lua
==============================================================================
    -- llm/utils/shell.lua - Shell command utilities
 12 local config = require('llm.config')

    -- License: Apache 2.0

 12 local M = {}
 12 local DEBUG = false

    -- Simple error notification wrapper
    local function notify_error(msg, level)
  6   vim.notify(msg, level or vim.log.levels.ERROR)
    end

    -- Private helper to log debug messages
    local function debug_log(message, level)
 35   if config.get('debug') then
**0     vim.notify(message, level or vim.log.levels.DEBUG)
      end
    end

    -- Execute shell command safely with error handling
 12 function M.safe_shell_command(cmd, error_msg)
 17   debug_log("Executing command: " .. cmd)

 17   local cmd_with_stderr = cmd .. " 2>&1"
 17   local result = vim.fn.system(cmd_with_stderr)

 17   if result == nil then
  1     notify_error("Command returned nil: " .. cmd)
  1     return nil, "Command returned nil"
      end

      -- Trim whitespace from result
 16   result = result:gsub("^%s*(.-)%s*$", "%1")

 16   if result == "" then
 14     debug_log("Command returned empty result", vim.log.levels.WARN)
 14     if error_msg then
  4       notify_error(error_msg, vim.log.levels.WARN)
  4       return nil, error_msg
        end
      else
  2     debug_log("Command result: " .. (result:len() > 200 and result:sub(1, 200) .. "..." or result))
      end

 12   return result, nil
    end

    -- Check if command exists in PATH
 12 function M.command_exists(cmd)
  2   local check_cmd = string.format("command -v %s >/dev/null 2>&1", cmd)
  2   return os.execute(check_cmd) == 0
    end

    -- Check if llm is installed and available
 12 function M.check_llm_installed()
**0   if not M.command_exists("llm") then
**0     notify_error("llm CLI not found. Install with: pip install llm or brew install llm")
**0     return false
      end
**0   return true
    end

    -- Execute command and return status, stdout, stderr
 12 function M.execute(cmd)
  2   local handle = io.popen(cmd .. " 2>&1", "r")
  2   if not handle then
**0     notify_error("Failed to execute command: " .. cmd)
**0     return nil, "Failed to execute command"
      end

  2   local output = handle:read("*a")
  2   local success, _, exit_code = handle:close()

  2   if not success or exit_code ~= 0 then
  1     notify_error("Command failed with exit code " .. exit_code .. ": " .. cmd)
  1     return nil, "Command failed"
      end

  1   return output, nil
    end

 12 local llm_nvim_data_dir = vim.fn.stdpath('data') .. '/llm-nvim'
 12 local last_update_file = llm_nvim_data_dir .. '/last_update_check.txt'

    -- Ensure the data directory exists
    local function ensure_data_dir_exists()
  4   if vim.fn.isdirectory(llm_nvim_data_dir) == 0 then
**0     vim.fn.mkdir(llm_nvim_data_dir, "p")
      end
    end

    -- Get the timestamp of the last update check
 12 function M.get_last_update_timestamp()
  1   ensure_data_dir_exists() -- Ensure directory exists before attempting to read
  1   local f = io.open(last_update_file, "r")
  1   if not f then
**0     return 0
      end
  1   local content = f:read("*a")
  1   f:close()
  1   local ts = tonumber(content)
  1   return ts or 0
    end

    -- Set the timestamp of the last update check
 12 function M.set_last_update_timestamp()
  3   ensure_data_dir_exists()
  3   local f = io.open(last_update_file, "w")
  3   if not f then
  2     debug_log("Failed to open last_update_check.txt for writing", vim.log.levels.ERROR)
  2     return
      end
  1   f:write(tostring(os.time()))
  1   f:close()
    end

 12 function M.run_update_command(cmd)
**0   local output = vim.fn.system(cmd .. " 2>&1")
**0   local exit_code = vim.v.shell_error
**0   return output, exit_code
    end

    -- Attempt to update the LLM CLI
 12 function M.update_llm_cli(bufnr, api_obj)
  2   M.set_last_update_timestamp()
  2   local update_methods = {
        {
  2       cmd_name = "uv",
  2       check_exists = true,
  2       command = "uv tool upgrade llm",
  2       success_msg = "llm CLI updated successfully via uv."
  2     },
        {
  2       cmd_name = "pipx",
  2       check_exists = true,
  2       command = "pipx upgrade llm",
  2       success_msg = "llm CLI updated successfully via pipx."
  2     },
        {
  2       cmd_name = "pip",
  2       check_exists = false, -- Assuming pip is often aliased or directly available if python is
  2       command = "pip install -U llm",
  2       success_msg = "llm CLI updated successfully via pip."
  2     },
        {
  2       cmd_name = "python-pip",
  2       check_exists = false, -- Assuming python is in path
  2       command = "python -m pip install --upgrade llm",
  2       success_msg = "llm CLI updated successfully via python -m pip."
  2     },
        {
  2       cmd_name = "brew",
  2       check_exists = true,
  2       command = "brew upgrade llm",
  2       success_msg = "llm CLI updated successfully via brew."
        }
  2   }

      local function run_next_update(index)
  8     if index > #update_methods then
  1       vim.api.nvim_buf_set_lines(bufnr, -1, -1, false, { "", "LLM CLI update process finished." })
  1       return
        end

  7     local method = update_methods[index]
  7     local cmd_parts = vim.split(method.command, ' ')
  7     local can_run = true

  7     if method.check_exists then
  5       if not M.command_exists(method.cmd_name) then
  4         vim.api.nvim_buf_set_lines(bufnr, -1, -1, false, { "", "--- Attempting with " .. method.cmd_name .. " (skipped: command not found) ---" })
  4         can_run = false
          end
        end

  7     if can_run then
  3       vim.api.nvim_buf_set_lines(bufnr, -1, -1, false, { "", "--- Attempting to update llm CLI using " .. method.cmd_name .. " ---" })
  6       api_obj.run_llm_command_streamed(cmd_parts, bufnr, {
            on_exit = function(job_id, exit_code, event_type)
  3           if exit_code == 0 then
  1             vim.api.nvim_buf_set_lines(bufnr, -1, -1, false, { "", method.success_msg })
  1             vim.api.nvim_buf_set_lines(bufnr, -1, -1, false, { "", "Update successful. Stopping further attempts." })
              else
  2             vim.api.nvim_buf_set_lines(bufnr, -1, -1, false, { "", method.cmd_name .. " update failed with exit code " .. exit_code .. "." })
  2             run_next_update(index + 1) -- Try next method
              end
            end,
            on_stderr = function(job_id, data, event_type)
**0           vim.api.nvim_buf_set_lines(bufnr, -1, -1, false, data)
            end,
  3       })
        else
  4       run_next_update(index + 1) -- Try next method if current one was skipped
        end
      end

  2   run_next_update(1) -- Start the update process
    end

 12 return M

==============================================================================
lua/llm/core/utils/text.lua
==============================================================================
    -- llm/core/utils/text.lua - Text manipulation utilities for llm-nvim
    -- License: Apache 2.0

 11 local M = {}

    -- Get visual selection
 11 function M.get_visual_selection(bufnr)
  1   local buf_to_use = bufnr or 0
  1   local start_pos = vim.fn.getpos("'<")
  1   local end_pos = vim.fn.getpos("'>")
  1   local start_line = start_pos[2]
  1   local end_line = end_pos[2]
  1   local start_col = start_pos[3]
  1   local end_col = end_pos[3]

  1   if start_line == 0 or end_line == 0 then
**0     return ""
      end

  1   local lines = vim.api.nvim_buf_get_lines(buf_to_use, start_line - 1, end_line, false)
  1   if #lines == 0 then
**0     return ""
      end

  1   if #lines == 1 then
  1     return string.sub(lines[1], start_col, end_col)
      else
**0     lines[#lines] = string.sub(lines[#lines], 1, end_col)
**0     lines[1] = string.sub(lines[1], start_col)
**0     return table.concat(lines, "\n")
      end
    end

    -- Capitalize the first letter of a string
 11 function M.capitalize(s)
  5   if not s or s == '' then return s end
  4   return s:sub(1, 1):upper() .. s:sub(2)
    end

    -- Escape special pattern characters in a string
 11 function M.escape_pattern(s)
      -- Escape these special pattern characters: ^$()%.[]*+-?
  1   local escaped = string.gsub(s, "[%(%)%.%+%-%*%?%[%]%^%$%%]", "%%%1")
  1   return escaped
    end

    -- Simple YAML Parser
    -- Parses a subset of YAML (dictionaries, lists, basic scalars) into a Lua table.
    -- Handles indentation for structure. Does not support complex types, anchors, etc.
 11 function M.parse_simple_yaml(filepath)
  1   local config = require('llm.config')
  1   local debug_mode = config.get('debug')

  1   if debug_mode then
**0     vim.notify("Parsing YAML file: " .. filepath, vim.log.levels.DEBUG)
      end

  1   local file = io.open(filepath, "r")
  1   if not file then
**0     if debug_mode then
**0       vim.notify("YAML file not found or could not be opened: " .. filepath, vim.log.levels.WARN)
        end
**0     return nil -- Return nil if file cannot be opened
      end

  1   local lines = {}
  8   for line in file:lines() do
  7     table.insert(lines, line)
      end
  1   file:close()

  1   local data = {}
  1   local stack = { { data = data, indent = -1 } }

      local function trim(s)
 17     return s:match("^%s*(.-)%s*$")
      end

  8   for _, line in ipairs(lines) do
  7     if not line:match("^%s*$") and not line:match("^%s*#") then
  7       local indent = line:match("^(%s*)"):len()
  7       local content = trim(line)

  8       while indent <= stack[#stack].indent do
  1         table.remove(stack)
          end

  7       local parent = stack[#stack].data

  7       local key, val = content:match("([^:]+):%s*(.*)")
  7       if key then
  5         key = trim(key)
  5         val = trim(val)
  5         if val == "" then
  2           parent[key] = {}
  2           table.insert(stack, { data = parent[key], indent = indent })
            else
  3           parent[key] = val
            end
          else
  2         local item = content:match("^-%s*(.*)")
  2         if item then
  2           table.insert(parent, item)
            end
          end
        end
      end

  1   return data
    end

 11 function M.wrap(text, width, indent)
  7   indent = indent or ''
  7   width = width or 80

  7   local words = {}
 35   for word in text:gmatch('%S+') do
 28     table.insert(words, word)
      end

  7   if #words == 0 then
  2     return ''
      end

  5   local lines = {}
  5   local current_line = indent .. words[1]

 28   for i = 2, #words do
 23     local word = words[i]
 23     if #current_line + 1 + #word > width then
  3       table.insert(lines, current_line)
  3       current_line = indent .. word
        else
 20       current_line = current_line .. ' ' .. word
        end
      end
  5   table.insert(lines, current_line)

  5   return table.concat(lines, '\n')
    end

 11 return M

==============================================================================
lua/llm/core/utils/ui.lua
==============================================================================
 15 local M = {}

    -- Common buffer configuration
 15 local DEFAULT_BUFFER_OPTS = {
 15   buftype = 'nofile',
 15   bufhidden = 'wipe',
 15   swapfile = false
    }

    -- Convert content string to lines array
    local function content_to_lines(content)
  6   local lines = {}
 10   for line in content:gmatch("[^\r\n]+") do
  4     table.insert(lines, line)
      end
  6   return lines
    end

    -- Configure a buffer with standard options
    local function configure_buffer(buf, opts)
  8   for opt, val in pairs(DEFAULT_BUFFER_OPTS) do
  6     vim.api.nvim_buf_set_option(buf, opt, val)
      end

  2   if opts.name then
  1     vim.api.nvim_buf_set_name(buf, opts.name)
      end

  2   if opts.filetype then
  2     vim.api.nvim_buf_set_option(buf, 'filetype', opts.filetype)
      end

  2   if opts.content then
  1     vim.api.nvim_buf_set_lines(buf, 0, -1, false, content_to_lines(opts.content))
      end
    end

 15 function M.create_prompt_buffer()
      -- Create a new vertical split
  3   vim.cmd('vnew')

      -- Get the new buffer
  3   local buf = vim.api.nvim_get_current_buf()

      -- Switch to insert mode
  3   vim.cmd('startinsert')

      -- Set the content of the buffer to a prompt
  3   local prompt_text = "Enter your prompt here and then save and close the buffer to continue."
  3   vim.api.nvim_buf_set_lines(buf, 0, -1, false, { prompt_text })

  3   local group = vim.api.nvim_create_augroup("LLMSavePrompt", { clear = true })
  6   vim.api.nvim_create_autocmd("BufWriteCmd", {
  3     group = group,
  3     buffer = buf,
        callback = function()
  1       local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
  1       table.remove(lines, 1)
  1       local content = table.concat(lines, "\n")
          -- The command needs to be loaded to be called.
  1       local commands = require('llm.commands')
  1       commands.prompt(content)
        end,
      })

  3   return buf
    end

 15 function M.create_chat_buffer()
      -- Create a new vertical split
  1   vim.cmd('vnew')

      -- Get the new buffer
  1   local buf = vim.api.nvim_get_current_buf()

      -- Get the model name
  1   local config = require('llm.config')
  1   local model_name = config.get("model") or "default"

      -- Generate a unique chat ID
  1   local chat_id = tostring(math.random(1000, 9999))

      -- Configure the buffer
  2   configure_buffer(buf, {
  1     name = "LLM Chat - " .. model_name .. " (" .. chat_id .. ")",
  1     filetype = "markdown"
      })

      -- Set the content of the buffer to a prompt
  1   local prompt_text = {
  1     '--- User Prompt ---',
  1     'Enter your prompt below and press <Enter> to submit.',
  1     '-------------------',
        ''
  1   }
  1   vim.api.nvim_buf_set_lines(buf, 0, -1, false, prompt_text)

      -- Set up keymap for <Enter>
  2   vim.api.nvim_buf_set_keymap(buf, 'i', '<Enter>', '<Cmd>lua require("llm.chat").send_prompt()<CR>',
  1     { noremap = true, silent = true })
      -- Add a keymap for closing the buffer
  1   vim.api.nvim_buf_set_keymap(buf, 'n', 'q', '<Cmd>bd<CR>', { noremap = true, silent = true })

      -- Move the cursor to the end of the prompt
  1   vim.api.nvim_win_set_cursor(0, { 4, 0 })

      -- Switch to insert mode
  1   vim.cmd('startinsert')

  1   return buf
    end

 15 function M.create_buffer_with_content(initial_content, buffer_name, filetype)
  1   local buf = vim.api.nvim_create_buf(false, true)

      -- Only set name if provided and buffer doesn't already have one
  1   if buffer_name and vim.api.nvim_buf_get_name(buf) == "" then
**0     vim.api.nvim_buf_set_name(buf, buffer_name)
      end

  1   if filetype then
  1     vim.api.nvim_buf_set_option(buf, 'filetype', filetype)
      end

  1   if initial_content then
  1     vim.api.nvim_buf_set_lines(buf, 0, -1, false, content_to_lines(initial_content))
      end

  1   return buf
    end

 15 function M.replace_buffer_with_content(content, buffer, filetype)
  2   configure_buffer(buffer, {
  1     filetype = filetype,
  1     content = content
      })
  1   return buffer
    end

    -- Common window configuration
    local function get_window_config(width_ratio, height_ratio, title)
  2   local width = math.floor(vim.o.columns * width_ratio)
  2   local height = math.floor(vim.o.lines * height_ratio)
  2   return {
  2     relative = 'editor',
  2     width = width,
  2     height = height,
  2     row = math.floor((vim.o.lines - height) / 2),
  2     col = math.floor((vim.o.columns - width) / 2),
  2     style = 'minimal',
  2     border = 'rounded',
  2     title = ' ' .. (title or 'LLM') .. ' ',
  2     title_pos = 'center'
  2   }
    end

 15 function M.create_floating_window(buf, title)
  1   local win = vim.api.nvim_open_win(buf, true, get_window_config(0.8, 0.8, title))
  1   vim.api.nvim_win_set_option(win, 'cursorline', true)
  1   vim.api.nvim_win_set_option(win, 'winblend', 0)
  1   return win
    end

    -- Common keybindings for floating windows
    local function set_floating_keymaps(buf, confirm_cmd, cancel_cmd)
  1   local keymaps = {
  1     { mode = 'i', key = '<CR>',  cmd = confirm_cmd },
  1     { mode = 'n', key = '<CR>',  cmd = confirm_cmd },
  1     { mode = '',  key = '<Esc>', cmd = cancel_cmd }
  1   }

  4   for _, km in ipairs(keymaps) do
  3     vim.api.nvim_buf_set_keymap(buf, km.mode, km.key, km.cmd, { noremap = true, silent = true })
      end
    end

 15 function M.floating_input(opts, on_confirm)
  1   local buf = vim.api.nvim_create_buf(false, true)
  1   local win = vim.api.nvim_open_win(buf, true, get_window_config(0.6, 1, opts.prompt or 'Input'))

  1   if opts.default then
**0     vim.api.nvim_buf_set_lines(buf, 0, -1, false, { opts.default })
      end

  2   set_floating_keymaps(buf,
  1     '<cmd>lua require("llm.core.utils.ui")._confirm_floating_input()<CR>',
        '<cmd>lua require("llm.core.utils.ui")._close_floating_input()<CR>'
  1   )

  2   vim.api.nvim_buf_set_var(buf, 'floating_input_callback', function(input)
**0     if on_confirm then on_confirm(input) end
      end)

  1   vim.api.nvim_command('startinsert')
    end

 15 function M._confirm_floating_input()
**0   local buf = vim.api.nvim_get_current_buf()
**0   local win = vim.api.nvim_get_current_win()
**0   local lines = vim.api.nvim_buf_get_lines(buf, 0, -1, false)
**0   local input = table.concat(lines, '\n')
**0   local callback = vim.api.nvim_buf_get_var(buf, 'floating_input_callback')
**0   vim.api.nvim_win_close(win, true)
**0   vim.api.nvim_command('stopinsert')
**0   if callback then
**0     callback(input)
      end
    end

 15 function M._close_floating_input()
**0   local win = vim.api.nvim_get_current_win()
**0   vim.api.nvim_win_close(win, true)
    end

    -- Create a floating confirmation dialog with styling
 15 function M.floating_confirm(opts)
  1   local prompt = opts.prompt or "Are you sure?"
  1   local on_confirm = opts.on_confirm or function() end

      -- Calculate window dimensions
  1   local width = math.min(math.floor(vim.o.columns * 0.4), 60)
  1   local height = 5 -- Increased height for better spacing
  1   local row = math.floor((vim.o.lines - height) / 2)
  1   local col = math.floor((vim.o.columns - width) / 2)

      -- Create window with styling
  1   local buf = vim.api.nvim_create_buf(false, true)
  1   local win_opts = {
  1     relative = 'editor',
  1     width = width,
  1     height = height,
  1     row = row,
  1     col = col,
  1     style = 'minimal',
  1     border = 'rounded',
  1     title = ' ' .. prompt .. ' ',
  1     title_pos = 'center',
  1     focusable = true,
  1     noautocmd = true,
  1     zindex = 50
      }

      -- Apply highlights before creating window
  1   vim.api.nvim_set_hl(0, 'LlmConfirmTitle', { fg = '#f8f8f2', bg = '#44475a', bold = true })
  1   vim.api.nvim_set_hl(0, 'LlmConfirmBorder', { fg = '#6272a4' })
  1   vim.api.nvim_set_hl(0, 'LlmConfirmText', { fg = '#f8f8f2' })
  1   vim.api.nvim_set_hl(0, 'LlmConfirmButton', { fg = '#50fa7b', bold = true })
  1   vim.api.nvim_set_hl(0, 'LlmConfirmButtonCancel', { fg = '#ff5555', bold = true })
  1   vim.api.nvim_set_hl(0, 'LlmUserPrompt', { fg = '#50fa7b' })    -- Green for user prompts
  1   vim.api.nvim_set_hl(0, 'LlmModelResponse', { fg = '#bd93f9' }) -- Purple for model responses

  1   local win = vim.api.nvim_open_win(buf, true, win_opts)

      -- Set window highlights
  2   vim.api.nvim_win_set_option(win, 'winhl',
  1     'Normal:LlmConfirmText,NormalFloat:LlmConfirmText,FloatBorder:LlmConfirmBorder,Title:LlmConfirmTitle')

      -- Add compact styled content that fits in 5 lines
  1   local lines = {
  1     "┌───────────────────────────────┐",
  1     "│  Confirm your action          │",
  1     "└───────────────────────────────┘",
  1     "",
        "  [Y]es    [N]o"
  1   }
  1   vim.api.nvim_buf_set_lines(buf, 0, -1, false, lines)

      -- Add highlights for the buttons
  1   vim.api.nvim_buf_add_highlight(buf, -1, 'LlmConfirmButton', 4, 3, 7)         -- Yes
  1   vim.api.nvim_buf_add_highlight(buf, -1, 'LlmConfirmButtonCancel', 4, 11, 13) -- No

      -- Set keymaps with better visual feedback
  2   vim.api.nvim_buf_set_keymap(buf, 'n', 'y', '<Cmd>lua require("llm.core.utils.ui")._confirm_floating_dialog(true)<CR>',
  1     { noremap = true, silent = true, desc = "Confirm action" })
  2   vim.api.nvim_buf_set_keymap(buf, 'n', 'Y', '<Cmd>lua require("llm.core.utils.ui")._confirm_floating_dialog(true)<CR>',
  1     { noremap = true, silent = true, desc = "Confirm action" })
  2   vim.api.nvim_buf_set_keymap(buf, 'n', 'n', '<Cmd>lua require("llm.core.utils.ui")._confirm_floating_dialog(false)<CR>',
  1     { noremap = true, silent = true, desc = "Cancel action" })
  2   vim.api.nvim_buf_set_keymap(buf, 'n', 'N', '<Cmd>lua require("llm.core.utils.ui")._confirm_floating_dialog(false)<CR>',
  1     { noremap = true, silent = true, desc = "Cancel action" })
  2   vim.api.nvim_buf_set_keymap(buf, 'n', '<Esc>', '<Cmd>lua require("llm.core.utils.ui")._confirm_floating_dialog(false)<CR>',
  1     { noremap = true, silent = true, desc = "Cancel action" })

      -- Store callback in buffer var
  1   vim.api.nvim_buf_set_var(buf, 'floating_confirm_callback', on_confirm)
    end

 15 function M._confirm_floating_dialog(confirmed)
**0   local buf = vim.api.nvim_get_current_buf()
**0   local callback = vim.api.nvim_buf_get_var(buf, 'floating_confirm_callback')
**0   vim.api.nvim_win_close(vim.api.nvim_get_current_win(), true)
**0   if confirmed then
**0     callback("Yes")
      else
**0     callback("No")
      end
    end

 15 function M.append_to_buffer(bufnr, content, highlight_group)
  8   vim.notify(
  4     "append_to_buffer called for bufnr: " .. tostring(bufnr) .. ", content length: " .. tostring(#(content or "")),
  4     vim.log.levels.DEBUG)
  4   local lines = content_to_lines(content or '')
  4   if #lines == 0 then
  2     vim.notify("append_to_buffer: No lines to append.", vim.log.levels.DEBUG)
  2     return
      end

  2   local ok, last_line = pcall(vim.api.nvim_buf_line_count, bufnr)
  2   if not ok then
  1     vim.notify("append_to_buffer: Invalid buffer number: " .. tostring(bufnr), vim.log.levels.ERROR)
  1     return -- Invalid buffer, do nothing
      end

  1   vim.api.nvim_buf_set_lines(bufnr, last_line, last_line, false, lines)

  1   if highlight_group then
**0     for i = 0, #lines - 1 do
**0       vim.api.nvim_buf_add_highlight(bufnr, -1, highlight_group, last_line + i, 0, -1)
        end
      end

  2   vim.notify("append_to_buffer: Appended " .. tostring(#lines) .. " lines to buffer " .. tostring(bufnr),
  1     vim.log.levels.DEBUG)

      -- Move cursor to the end of the buffer if it's the current buffer
  1   if vim.api.nvim_get_current_buf() == bufnr then
  1     vim.api.nvim_win_set_cursor(0, { last_line + #lines, 0 })
  1     vim.notify("append_to_buffer: Cursor moved in current window", vim.log.levels.DEBUG)
      else
**0     vim.notify("append_to_buffer: Not current buffer, cursor not moved.", vim.log.levels.DEBUG)
      end
    end

 15 return M

==============================================================================
lua/llm/core/utils/validate.lua
==============================================================================
    -- llm/utils/validate.lua - Type validation and conversion utilities
    -- License: Apache 2.0

 18 local M = {}

    -- Type conversion functions
 18 function M.convert(value, target_type)
  5   if type(value) == target_type then
  2     return value
      end

  3   if target_type == "boolean" then
  2     if type(value) == "string" then
  2       return value:lower() == "true"
**0     elseif type(value) == "number" then
**0       return value ~= 0
        end
  1   elseif target_type == "number" then
  1     if type(value) == "string" then
  1       return tonumber(value) or 0
**0     elseif type(value) == "boolean" then
**0       return value and 1 or 0
        end
**0   elseif target_type == "string" then
**0     return tostring(value)
      end

      -- Fallback to default for target type
**0   if target_type == "boolean" then
**0     return false
**0   elseif target_type == "number" then
**0     return 0
**0   elseif target_type == "string" then
**0     return ""
**0   elseif target_type == "table" then
**0     return {}
      end

**0   return nil
    end

    -- Validate value against type
 18 function M.validate(value, expected_type)
  6   if expected_type == "any" then
**0     return true
      end
      
  6   local actual_type = type(value)
      
      -- Special case for nil which we'll consider valid for all types
  6   if value == nil then
**0     return true
      end
      
      -- Handle table type checks
  6   if expected_type == "table" and actual_type == "table" then
**0     return true
      end
      
      -- Handle other type matches
  6   return actual_type == expected_type
    end

 18 return M

==============================================================================
lua/llm/errors.lua
==============================================================================
    -- llm/errors.lua - Centralized error handling system
    -- License: Apache 2.0

  7 local M = {}
  7 local config = require('llm.config')
  7 local notify_util = require('llm.core.utils.notify')

    -- Error severity levels
  7 M.levels = {
  7   INFO = 1,
  7   WARNING = 2,
  7   ERROR = 3,
  7   CRITICAL = 4
  7 }

    -- Error categories
  7 M.categories = {
  7   CONFIG = 'config',
  7   MODEL = 'model',
  7   PLUGIN = 'plugin',
  7   KEY = 'key',
  7   FRAGMENT = 'fragment',
  7   TEMPLATE = 'template',
  7   SCHEMA = 'schema',
  7   INTERNAL = 'internal',
  7   SHELL = 'shell'
  7 }

    -- Format error message
    local function format_message(category, message, details)
  6   return string.format('[%s] %s%s',
  3     category:upper(),
  3     message,
  3     details and ' | '..vim.inspect(details) or '')
    end

    -- Handle and report error
  7 function M.handle(category, message, details, severity, notify_fn)
  3   local notify = notify_fn or vim.notify
  3   severity = severity or M.levels.ERROR
  3   category = category or M.categories.INTERNAL

  3   local formatted = format_message(category, message, details)

      -- Log based on severity
  3   if severity >= M.levels.ERROR then
  3     notify(formatted, vim.log.levels.ERROR)
**0   elseif severity == M.levels.WARNING then
**0     notify(formatted, vim.log.levels.WARN)
      else
**0     notify(formatted, vim.log.levels.INFO)
      end

      -- Return structured error for programmatic handling
  3   return {
  3     category = category,
  3     message = message,
  3     details = details,
  3     severity = severity,
  3     formatted = formatted
  3   }
    end

    -- Create error wrappers for common patterns
  7 function M.wrap(fn, category)
      return function(...)
  2     local ok, result = pcall(fn, ...)
  2     if not ok then
  1       return M.handle(category, result)
        end
  1     return result
      end
    end

    -- Shell command specific handler
  7 function M.shell_error(command, code, stdout, stderr)
  1   local output = stdout
  1   if stderr and #stderr > 0 then
  1     output = output .. "\n" .. stderr
      end
  2   return M.handle(
  1     'shell',
  1     string.format('Command failed: %s (exit code %d)', command, code),
  1     output,
  1     M.levels.ERROR
  1   )
    end

  7 return M

==============================================================================
lua/llm/facade.lua
==============================================================================
    -- llm/facade.lua - Centralized API surface for llm-nvim
    -- License: Apache 2.0

 22 local M = {}

    -- Manager registry and cache
 22 local managers = {
 22   models = nil,
 22   keys = nil,
 22   fragments = nil,
 22   templates = nil,
 22   schemas = nil,
 22   plugins = nil,
 22   unified = nil,
    }

 22 local manager_files = {
 22   models = 'llm.managers.models_manager',
 22   keys = 'llm.managers.keys_manager',
 22   fragments = 'llm.managers.fragments_manager',
 22   templates = 'llm.managers.templates_manager',
 22   schemas = 'llm.managers.schemas_manager',
 22   plugins = 'llm.managers.plugins_manager',
 22   unified = 'llm.ui.unified_manager',
    }

    -- Get manager instances with lazy loading
 22 function M.get_manager(name)
  6   if not managers[name] and manager_files[name] then
  3     managers[name] = require(manager_files[name])
      end
  6   return managers[name]
    end

 22 if vim.env.NVIM_LLM_TEST then
  1   function M._get_managers()
  1     return managers
      end
    end

    -- Unified LLM command handler
 22 function M.command(subcmd, ...)
  1   return require('llm.commands').dispatch_command(subcmd, ...)
    end

    -- Prompt functions
 22 function M.prompt(prompt, fragment_paths)
  1   return require('llm.commands').prompt(prompt, fragment_paths)
    end

 22 function M.prompt_with_selection(prompt, fragment_paths)
  1   return require('llm.commands').prompt_with_selection(prompt, fragment_paths)
    end

 22 function M.prompt_with_current_file(prompt)
  1   return require('llm.commands').prompt_with_current_file(prompt)
    end

    -- Unified manager functions
 22 function M.toggle_unified_manager(initial_view)
  1   local unified_manager = M.get_manager('unified')
  1   if unified_manager then
  1     return unified_manager.toggle(initial_view)
      else
**0     error("Failed to load unified manager")
      end
    end

 22 return M

==============================================================================
lua/llm/init.lua
==============================================================================
    -- llm/init.lua - Entry point for lazy.nvim integration
    -- License: Apache 2.0

  6 local M = {}
  6 local facade = require('llm.facade')
  6 local loaders = require('llm.core.loaders')

    -- Setup function for configuration
  6 function M.setup(opts)
      -- Initialize config first
  6   M.config = require('llm.config')
  6   M.config.setup(opts or {})

      -- Initialize styles
  6   require('llm.ui.styles').setup_highlights()



      -- Load all data
  6   loaders.load_all()

      -- Auto-update LLM CLI check
  6   local auto_update_cli = M.config.get('auto_update_cli')
  6   local auto_update_interval_days = M.config.get('auto_update_interval_days')

  6   if auto_update_cli then
  2     local shell = require('llm.core.utils.shell')
  2     local last_update_ts = shell.get_last_update_timestamp()
  2     local current_ts = os.time()
  2     local days_since_last_update = (current_ts - last_update_ts) / (60 * 60 * 24)

  2     if days_since_last_update >= auto_update_interval_days then
  1       vim.notify("LLM-Nvim: Checking for LLM CLI updates...", vim.log.levels.INFO)
  2       vim.defer_fn(function()
  1         local result = shell.update_llm_cli(nil, M)
  1         if result and result.success then
  1           vim.notify("LLM CLI auto-update successful.", vim.log.levels.INFO)
**0         elseif result then
**0           local msg = "LLM CLI auto-update failed."
**0           if result.message and string.len(result.message) > 0 then
**0             msg = msg .. " Details:\n" .. result.message
                 -- Check if notify module is available to use more advanced notification
**0             local notify_mod = require('llm.core.utils.notify')
**0             if notify_mod and notify_mod.notify then
**0               notify_mod.notify(msg, vim.log.levels.WARN, {title = "LLM Auto-Update"})
                else
**0               vim.notify(msg, vim.log.levels.WARN)
                end
              else
**0             vim.notify(msg, vim.log.levels.WARN)
              end
            else
**0           vim.notify("LLM CLI auto-update check failed to run.", vim.log.levels.ERROR)
            end
  2       end, 100) -- Short delay to not block startup critical path
        end
      end

      -- Defer the plugin refresh to avoid circular dependencies
 12   vim.defer_fn(function()
  6     local plugins_manager = require('llm.managers.plugins_manager')
  6     plugins_manager.refresh_available_plugins()
 12   end, 100)



  6   return M
    end

    -- Expose facade functions
 42 for k, v in pairs(facade) do
 36   M[k] = v
    end

    -- Expose functions to global scope for testing purposes only
  6 if vim.env.LLM_NVIM_TEST then
**0   for k, v in pairs(facade) do
**0     _G[k] = v
      end
    end

  6 return M

==============================================================================
lua/llm/managers/custom_openai.lua
==============================================================================
    -- llm/managers/custom_openai.lua - Custom OpenAI model management
    -- License: Apache 2.0

  9 local M = {}
  9 local config = require('llm.config')
  9 local keys_manager = require('llm.managers.keys_manager')
  9 local file_utils = require('llm.core.utils.file_utils')
  9 local text_utils = require('llm.core.utils.text')

    -- Cache for custom OpenAI models
  9 M.custom_openai_models = {}

  9 function M.get_custom_openai_models()
**0   return M.custom_openai_models
    end

    -- Default values for model properties
  9 local DEFAULT_MODEL_PROPERTIES = {
  9   needs_auth = true,
  9   supports_functions = false,
  9   supports_system_prompt = true,
  9   headers = nil,
  9   api_base = nil,
  9   api_key_name = nil,
    }

    -- Load custom OpenAI models from extra-openai-models.yaml
  9 function M.load_custom_openai_models()
  5   M.custom_openai_models = {} -- Clear the cache

  5   local _, yaml_path = file_utils.get_config_path("extra-openai-models.yaml")
  5   if config.get("debug") then
**0     vim.notify("Looking for custom OpenAI models at: " .. (yaml_path or "path not found"), vim.log.levels.INFO)
      end

  5   if not yaml_path then
  2     vim.notify("Could not determine or create config directory for extra-openai-models.yaml", vim.log.levels.WARN)
  2     return {}
      end

  3   local file = io.open(yaml_path, "r")
  3   if not file then
  1     if config.get("debug") then
**0       vim.notify("extra-openai-models.yaml not found at: " .. yaml_path .. ". No custom models loaded.", vim.log.levels.INFO)
        end
  1     return {}
      end

  2   local content = file:read("*a")
  2   file:close()
  2   if not content or content == "" then
**0     if config.get("debug") then
**0       vim.notify("extra-openai-models.yaml is empty. No custom models loaded.", vim.log.levels.INFO)
        end
**0     return {}
      end

  2   local parsed_data = text_utils.parse_simple_yaml(yaml_path)
  2   if not parsed_data then
  1     if config.get("debug") then
**0       vim.notify("Failed to parse YAML file: " .. yaml_path .. ". Backing up and proceeding as if empty.", vim.log.levels.WARN)
        end
  1     local backup_path = yaml_path .. ".parse_failed_backup." .. os.time()
  1     os.rename(yaml_path, backup_path)
  1     vim.notify("Backed up unparsable YAML to: " .. backup_path, vim.log.levels.WARN)
  1     return {}
      end

      -- Check if parsed_data is a list
  1   local is_list = type(parsed_data) == 'table'
  1   if is_list then
  1     local count = 0
  3     for k, _ in pairs(parsed_data) do
  2       count = count + 1
  2       if type(k) ~= 'number' or k < 1 then is_list = false; break end
        end
  1     if count > 0 and not parsed_data[1] then is_list = false end
  1     if #parsed_data ~= count then is_list = false end
      end

  1   if not is_list then
**0     if config.get("debug") then
**0       vim.notify("YAML content in " .. yaml_path .. " is not a list. Backing up and proceeding as if empty.", vim.log.levels.WARN)
        end
**0     local backup_path = yaml_path .. ".non_list_backup." .. os.time()
**0     os.rename(yaml_path, backup_path)
**0     vim.notify("Backed up non-list YAML to: " .. backup_path, vim.log.levels.WARN)
**0     return {}
      end

  3   for i, model_def in ipairs(parsed_data) do
  2     if type(model_def) == 'table' then
  2       local primary_id = model_def.model_id
  2       if not primary_id or primary_id == "" then
**0         if config.get("debug") then
**0           vim.notify("Skipping model definition at index " .. i .. " due to missing 'model_id'", vim.log.levels.WARN)
            end
          else
  2         local model_data = {
  2           model_id = primary_id,
  2           model_name = model_def.model_name or primary_id,
  2           api_base = model_def.api_base or DEFAULT_MODEL_PROPERTIES.api_base,
  2           api_key_name = model_def.api_key_name or DEFAULT_MODEL_PROPERTIES.api_key_name,
  2           headers = DEFAULT_MODEL_PROPERTIES.headers, -- Default to nil
  2           needs_auth = (model_def.needs_auth == nil) and DEFAULT_MODEL_PROPERTIES.needs_auth or model_def.needs_auth,
  2           supports_functions = (model_def.supports_functions == nil) and DEFAULT_MODEL_PROPERTIES.supports_functions or model_def.supports_functions,
  2           supports_system_prompt = (model_def.supports_system_prompt == nil) and DEFAULT_MODEL_PROPERTIES.supports_system_prompt or model_def.supports_system_prompt,
  2           is_valid = false -- Will be set by M.is_custom_openai_model_valid
            }

            -- Handle headers (string or table)
  2         if model_def.headers then
**0           if type(model_def.headers) == 'string' then
**0             local success, decoded_headers = pcall(vim.fn.json_decode, model_def.headers)
**0             if success then
**0               model_data.headers = decoded_headers
                else
**0               if config.get("debug") then
**0                 vim.notify("Failed to parse JSON string for headers for model " .. primary_id .. ": " .. model_def.headers, vim.log.levels.WARN)
                  end
                end
**0           elseif type(model_def.headers) == 'table' then
**0             model_data.headers = model_def.headers
              end
            end

            -- Validate the model (sets model_data.is_valid)
  2         M.is_custom_openai_model_valid(model_data) -- Pass the whole model_data for validation context

  2         M.custom_openai_models[primary_id] = model_data
  2         if config.get("debug") then
**0           vim.notify(string.format("Loaded custom model: ID=%s, Name=%s, Valid=%s, Auth=%s, Funcs=%s, SysPrompt=%s, Headers=%s",
**0             primary_id, model_data.model_name, tostring(model_data.is_valid), tostring(model_data.needs_auth),
**0             tostring(model_data.supports_functions), tostring(model_data.supports_system_prompt), vim.inspect(model_data.headers)), vim.log.levels.DEBUG)
            end
          end
        else
**0       if config.get("debug") then
**0         vim.notify("Skipping non-table entry in parsed YAML data at index " .. i, vim.log.levels.WARN)
          end
        end
      end
  1   return M.custom_openai_models
    end

    -- Check if a custom OpenAI model identifier corresponds to a valid configuration
    -- Can be called with a model_id string or directly with a model_data table
  9 function M.is_custom_openai_model_valid(model_identifier_or_data)
      local model_info
  7   if type(model_identifier_or_data) == 'string' then
  2     if not model_identifier_or_data or model_identifier_or_data == "" then return false end
        -- Ensure models are loaded if called with just an ID
  2     if vim.tbl_isempty(M.custom_openai_models) then
  2       M.load_custom_openai_models()
        end
  2     model_info = M.custom_openai_models[model_identifier_or_data]
  5   elseif type(model_identifier_or_data) == 'table' then
  5     model_info = model_identifier_or_data -- model_data was passed directly
      else
**0     return false -- Invalid argument
      end

  7   if not model_info then return false end

      -- If needs_auth is explicitly false, model is valid (even without API key name or set key)
  5   if model_info.needs_auth == false then
  2     model_info.is_valid = true
  2     return true
      end

      -- If needs_auth is true (or default), api_key_name must exist and key must be set
  3   if model_info.api_key_name and model_info.api_key_name ~= "" then
  3     if keys_manager.is_key_set(model_info.api_key_name) then
  2       model_info.is_valid = true
  2       return true
        else
  1       if config.get("debug") then
**0         vim.notify("API key '" .. model_info.api_key_name .. "' not set for custom model: " .. model_info.model_id, vim.log.levels.DEBUG)
          end
  1       model_info.is_valid = false
  1       return false
        end
      else
        -- needs_auth is true but no api_key_name defined
**0     if config.get("debug") then
**0       vim.notify("Custom model '" .. model_info.model_id .. "' requires auth but no api_key_name is defined.", vim.log.levels.DEBUG)
        end
**0     model_info.is_valid = false
**0     return false
      end
    end

    -- Debug function for custom models
  9 function M.debug_custom_openai_models()
**0   local config_dir, yaml_path = file_utils.get_config_path("extra-openai-models.yaml")

**0   vim.notify("Debug information for custom OpenAI models:", vim.log.levels.INFO)
**0   vim.notify("Config directory: " .. (config_dir or "not found"), vim.log.levels.INFO)
**0   vim.notify("YAML path: " .. (yaml_path or "not found"), vim.log.levels.INFO)

      -- Check file existence and content
**0   if yaml_path then
**0     local file = io.open(yaml_path, "r")
**0     if file then
**0       local content = file:read("*a")
**0       file:close()
**0       vim.notify("File exists with " .. #content .. " bytes", vim.log.levels.INFO)
        end
      end

      -- Load and show models
**0   M.load_custom_openai_models()
**0   vim.notify("Found " .. vim.tbl_count(M.custom_openai_models) .. " custom OpenAI models", vim.log.levels.INFO)

**0   for name, model in pairs(M.custom_openai_models) do
**0     local status = model.is_valid and "valid" or "invalid"
**0     vim.notify(string.format("Model: %s, Status: %s, API Key: %s, Has API Base: %s",
**0       name, status, model.api_key_name or "not set", model.has_api_base and "yes" or "no"), vim.log.levels.INFO)
      end

**0   return M.custom_openai_models
    end

    -- Create sample YAML file
  9 function M.create_sample_yaml_file()
**0   local config_dir, yaml_path = file_utils.get_config_path("extra-openai-models.yaml.sample")

**0   if not config_dir then
**0     vim.notify("Could not find config directory", vim.log.levels.ERROR)
**0     return false
      end

      local sample_content = [[# Sample extra-openai-models.yaml
    # This file allows defining custom OpenAI-compatible models or overriding properties.
    # Models are defined as a YAML list.
    #
    # - model_id: (Required) The unique identifier for the model.
    #   model_name: (Optional) A user-friendly display name. Defaults to model_id.
    #   api_base: (Optional) The base URL for the API.
    #               Example: https://api.example.com/v1
    #   api_key_name: (Optional) The name of the key to use from keys.json.
    #                 Required if 'needs_auth' is true or not specified.
    #                 Example: my_custom_api_key
    #   headers: (Optional) Custom headers to send with requests.
    #            Can be a JSON string or a YAML map.
    #            Example as JSON string: '{"X-My-Header": "value"}'
    #            Example as YAML map:
    #              X-My-Header: value
    #              Authorization: Bearer your_static_token # If token is static and not from keys.json
    #   needs_auth: (Optional) Whether this model requires an API key via 'api_key_name'.
    #               Default: true
    #   supports_functions: (Optional) Whether this model supports function calling.
    #                       Default: false
    #   supports_system_prompt: (Optional) Whether this model supports system prompts.
    #                           Default: true

    - model_id: my-custom-gpt4-turbo
      model_name: My Custom GPT-4 Turbo (Needs Auth)
      api_base: https://my.openai.proxy/v1
      api_key_name: my_proxy_key # Must be set in keys.json
      # headers: '{"X-Custom-Billing-ID": "project-123"}' # Example JSON string for headers
      # supports_functions: true # Uncomment if it supports functions

    - model_id: anyscale-llama3-70b
      model_name: Anyscale Llama3 70B
      api_base: https://api.endpoints.anyscale.com/v1
      api_key_name: anyscale_token # Must be set in keys.json
      supports_functions: true
      supports_system_prompt: true

    - model_id: local-model-no-auth
      model_name: Local Model (No Auth)
      api_base: http://localhost:1234/v1
      needs_auth: false # No API key needed
      supports_system_prompt: false
      # headers: # Example YAML map for headers
      #   X-Forwarded-To: "llm-nvim"

    # - model_id: azure-deployment-id # Example for Azure
    #   model_name: Azure GPT-4 Turbo
    #   api_base: https://your-resource.openai.azure.com/openai/deployments/YOUR_DEPLOYMENT_ID
    #   api_key_name: azure_openai_key # Key for your Azure OpenAI service in keys.json
    #   # For Azure, 'api-version' is often required in headers or as a query param.
    #   # If using headers:
    #   # headers:
    #   #   api-key: Will be overridden by keys.json if api_key_name is also set.
    #   #            Prefer api_key_name for dynamic keys.
    #   #   Api-Version: "2024-02-15-preview" # Or your desired API version
    #   # If needs_auth is true (default), the key from api_key_name will be added
    #   # to headers as 'Authorization: Bearer <key_value>'.
    #   # If your Azure setup needs 'api-key' header instead, manage it through static headers
    #   # and potentially set needs_auth: false if the key is only in the header.
**0 ]]

**0   local file = io.open(yaml_path, "w")
**0   if not file then
**0     vim.notify("Could not create sample YAML file: " .. yaml_path, vim.log.levels.ERROR)
**0     return false
      end

**0   file:write(sample_content)
**0   file:close()

**0   vim.notify("Created sample YAML file at: " .. yaml_path, vim.log.levels.INFO)
**0   return true
    end

    -- Helper function to serialize a list of models to YAML
  9 function M.serialize_to_yaml(models_list)
**0   local yaml_lines = {}
**0   if not models_list or #models_list == 0 then
**0     return ""
      end

**0   for _, model in ipairs(models_list) do
**0     if model.model_id and model.model_id ~= "" then
**0       table.insert(yaml_lines, "- model_id: " .. model.model_id)

**0       if model.model_name and model.model_name ~= "" then
**0         table.insert(yaml_lines, "  model_name: " .. model.model_name)
          end
**0       if model.api_base and model.api_base ~= "" then
**0         table.insert(yaml_lines, "  api_base: " .. model.api_base)
          end
**0       if model.api_key_name and model.api_key_name ~= "" then
**0         table.insert(yaml_lines, "  api_key_name: " .. model.api_key_name)
          end

          -- Handle headers: serialize table to JSON string
**0       if model.headers then
**0         if type(model.headers) == 'table' and not vim.tbl_isempty(model.headers) then
**0           local success, json_str = pcall(vim.fn.json_encode, model.headers)
**0           if success then
                -- Represent JSON string as a YAML string literal (e.g., using single quotes)
**0             table.insert(yaml_lines, "  headers: '" .. json_str:gsub("'", "''") .. "'")
**0           elseif config.get("debug") then
**0             vim.notify("Failed to serialize headers table to JSON for model " .. model.model_id, vim.log.levels.WARN)
              end
**0         elseif type(model.headers) == 'string' and model.headers ~= "" then
               -- If it's already a string (presumably JSON), quote it properly for YAML
**0            table.insert(yaml_lines, "  headers: '" .. model.headers:gsub("'", "''") .. "'")
            end
          end

**0       if model.needs_auth == false then -- Only write if explicitly false (default is true)
**0         table.insert(yaml_lines, "  needs_auth: false")
          end
**0       if model.supports_functions == true then -- Only write if explicitly true (default is false)
**0         table.insert(yaml_lines, "  supports_functions: true")
          end
**0       if model.supports_system_prompt == false then -- Only write if explicitly false (default is true)
**0         table.insert(yaml_lines, "  supports_system_prompt: false")
          end
        else
**0       if config.get("debug") then
**0         vim.notify("Skipping serialization of model due to missing model_id: " .. vim.inspect(model), vim.log.levels.WARN)
          end
        end
      end
**0   return table.concat(yaml_lines, "\n") .. "\n"
    end

    -- Add a new custom OpenAI model to the extra-openai-models.yaml file
  9 function M.add_custom_openai_model(model_details)
**0   if not model_details or not model_details.model_id or model_details.model_id == "" then
**0     return false, "model_id is required"
      end

**0   local _, yaml_path = file_utils.get_config_path("extra-openai-models.yaml")
**0   if not yaml_path then
**0     return false, "Could not determine or create config directory for extra-openai-models.yaml"
      end

**0   local models_list = {}
**0   local file = io.open(yaml_path, "r")
**0   if file then
**0     local content = file:read("*a")
**0     file:close()
**0     if content and content ~= "" then
**0       local parsed_data = text_utils.parse_simple_yaml(yaml_path)
**0       if type(parsed_data) == 'table' then
**0         local is_list = true
**0         local count = 0
**0         for k, _ in pairs(parsed_data) do count = count + 1; if type(k) ~= 'number' or k < 1 then is_list = false; break end end
**0         if count > 0 and not parsed_data[1] then is_list = false end
**0         if #parsed_data ~= count then is_list = false end

**0         if is_list then
**0           models_list = parsed_data
            else
**0           if config.get("debug") then vim.notify("YAML content in " .. yaml_path .. " is not a list. Backing up.", vim.log.levels.WARN) end
**0           local backup_path = yaml_path .. ".non_list_backup." .. os.time()
**0           os.rename(yaml_path, backup_path)
**0           vim.notify("Backed up non-list YAML to: " .. backup_path, vim.log.levels.WARN)
**0           models_list = {}
            end
          else
**0         if config.get("debug") then vim.notify("Failed to parse YAML in " .. yaml_path .. ". Backing up.", vim.log.levels.WARN) end
**0         local backup_path = yaml_path .. ".parse_failed_backup." .. os.time()
**0         os.rename(yaml_path, backup_path)
**0         vim.notify("Backed up unparsable YAML to: " .. backup_path, vim.log.levels.WARN)
**0         models_list = {}
          end
        end
      end

      -- Prepare the new model entry with defaults for new fields
**0   local new_model_entry = {
        model_id = model_details.model_id,
        model_name = (model_details.model_name and model_details.model_name ~= "") and model_details.model_name or model_details.model_id,
        api_base = (model_details.api_base and model_details.api_base ~= "") and model_details.api_base or DEFAULT_MODEL_PROPERTIES.api_base,
        api_key_name = (model_details.api_key_name and model_details.api_key_name ~= "") and model_details.api_key_name or DEFAULT_MODEL_PROPERTIES.api_key_name,
        needs_auth = (model_details.needs_auth == nil) and DEFAULT_MODEL_PROPERTIES.needs_auth or model_details.needs_auth,
        supports_functions = (model_details.supports_functions == nil) and DEFAULT_MODEL_PROPERTIES.supports_functions or model_details.supports_functions,
        supports_system_prompt = (model_details.supports_system_prompt == nil) and DEFAULT_MODEL_PROPERTIES.supports_system_prompt or model_details.supports_system_prompt,
        headers = DEFAULT_MODEL_PROPERTIES.headers,
      }

**0   if model_details.headers then
**0     if type(model_details.headers) == 'table' then
**0       new_model_entry.headers = model_details.headers
**0     elseif type(model_details.headers) == 'string' and model_details.headers ~= "" then
**0       local success, decoded = pcall(vim.fn.json_decode, model_details.headers)
**0       if success and type(decoded) == 'table' then
**0         new_model_entry.headers = decoded
          else
**0         if config.get("debug") then vim.notify("Could not parse headers JSON string when adding model: " .. model_details.headers, vim.log.levels.WARN) end
             -- Store as string if not parsable as table, serializer will handle it.
**0         new_model_entry.headers = model_details.headers
          end
        end
      end

**0   table.insert(models_list, new_model_entry)
**0   local yaml_content = M.serialize_to_yaml(models_list)

**0   local out_file = io.open(yaml_path, "w")
**0   if not out_file then
**0     return false, "Failed to open YAML file for writing: " .. yaml_path
      end

**0   out_file:write(yaml_content)
**0   out_file:close()

      -- Clear the cache so it reloads next time
**0   M.custom_openai_models = {}

**0   return true, nil -- Success, no error message
    end

    -- Delete a custom OpenAI model from the extra-openai-models.yaml file
  9 function M.delete_custom_openai_model(model_id)
**0   if not model_id or model_id == "" then
**0     return false, "model_id is required"
      end

**0   local _, yaml_path = file_utils.get_config_path("extra-openai-models.yaml")
**0   if not yaml_path then
**0     return false, "Could not determine or create config directory for extra-openai-models.yaml"
      end

**0   local models_list = {}
**0   local file = io.open(yaml_path, "r")
**0   if file then
**0     local content = file:read("*a")
**0     file:close()
**0     if content and content ~= "" then
**0       local parsed_data = text_utils.parse_simple_yaml(yaml_path)
**0       if type(parsed_data) == 'table' then
**0         local is_list = true
**0         local count = 0
**0         for k, _ in pairs(parsed_data) do count = count + 1; if type(k) ~= 'number' or k < 1 then is_list = false; break end end
**0         if count > 0 and not parsed_data[1] then is_list = false end
**0         if #parsed_data ~= count then is_list = false end

**0         if is_list then
**0           models_list = parsed_data
            else
**0           if config.get("debug") then vim.notify("YAML content in " .. yaml_path .. " is not a list. Backing up.", vim.log.levels.WARN) end
**0           local backup_path = yaml_path .. ".non_list_backup." .. os.time()
**0           os.rename(yaml_path, backup_path)
**0           vim.notify("Backed up non-list YAML to: " .. backup_path, vim.log.levels.WARN)
**0           models_list = {}
            end
          else
**0         if config.get("debug") then vim.notify("Failed to parse YAML in " .. yaml_path .. ". Backing up.", vim.log.levels.WARN) end
**0         local backup_path = yaml_path .. ".parse_failed_backup." .. os.time()
**0         os.rename(yaml_path, backup_path)
**0         vim.notify("Backed up unparsable YAML to: " .. backup_path, vim.log.levels.WARN)
**0         models_list = {}
          end
        end
      end

**0   local new_models_list = {}
**0   for _, model in ipairs(models_list) do
**0     if model.model_id ~= model_id then
**0       table.insert(new_models_list, model)
        end
      end

**0   local yaml_content = M.serialize_to_yaml(new_models_list)

**0   local out_file = io.open(yaml_path, "w")
**0   if not out_file then
**0     return false, "Failed to open YAML file for writing: " .. yaml_path
      end

**0   out_file:write(yaml_content)
**0   out_file:close()

      -- Clear the cache so it reloads next time
**0   M.custom_openai_models = {}

**0   return true, nil -- Success, no error message
    end

  9 return M

==============================================================================
lua/llm/managers/fragments_manager.lua
==============================================================================
    -- llm/managers/fragments_manager.lua - Fragment management functionality for llm-nvim
    -- License: Apache 2.0

  1 local M = {}

    -- Forward declarations
  1 local api = vim.api
  1 local fn = vim.fn
  1 local llm_cli = require('llm.core.data.llm_cli')
  1 local cache = require('llm.core.data.cache')
  1 local fragments_view = require('llm.ui.views.fragments_view')
  1 local styles = require('llm.ui.styles')

    -- Get fragments from llm CLI
  1 function M.get_fragments()
  3     local cached_fragments = cache.get('fragments')
  3     if cached_fragments then
  1         return cached_fragments
        end

  2     local fragments_json = llm_cli.run_llm_command('fragments list --json')
  2     local fragments = vim.fn.json_decode(fragments_json)
  2     cache.set('fragments', fragments)
  2     return fragments
    end

    -- Populate the buffer with fragment management content
  1 function M.populate_fragments_buffer(bufnr)
**0   local show_all = _G.llm_fragments_show_all or false
**0   local fragments = M.get_fragments()
**0   local show_mode = show_all and "all" or "with_aliases"

**0   local lines = {
        "# Fragment Management",
        "",
        "Navigate: [M]odels [P]lugins [K]eys [T]emplates [S]chemas",
        "Actions: [v]iew [a]dd alias [r]emove alias [n]ew file [g]itHub [p]rompt [t]oggle view [q]uit",
        "──────────────────────────────────────────────────────────────",
        "",
**0     "Showing: " .. (show_mode == "all" and "All fragments" or "Only fragments with aliases"),
        ""
      }

**0   local fragment_data = {}
**0   local line_to_fragment = {}
**0   local current_line = #lines + 1

**0   if #fragments == 0 then
**0     table.insert(lines, "No fragments found.")
**0     table.insert(lines, "Use 'n' to add a new fragment from a file.")
      else
**0     for i, fragment in ipairs(fragments) do
**0       if not show_all and (#fragment.aliases == 0) then
            -- Skip to the next iteration
          else
**0         local aliases = #fragment.aliases > 0 and table.concat(fragment.aliases, ", ") or "none"
**0         local source = fragment.source or "unknown"
**0         local first_line = fragment.content:match("^[^\r\n]*") or ""
**0         local content_preview = first_line
**0         if #content_preview > 50 then
**0           content_preview = content_preview:sub(1, 47) .. "..."
**0         elseif #fragment.content > #content_preview then
**0           content_preview = content_preview .. "..."
            end

**0         local entry_lines = {
**0           string.format("Fragment %d: %s", i, fragment.hash),
**0           string.format("  Source: %s", source),
**0           string.format("  Aliases: %s", aliases),
**0           string.format("  Date: %s", fragment.datetime or "unknown"),
**0           string.format("  Content: %s", content_preview),
              ""
            }
**0         for _, line in ipairs(entry_lines) do table.insert(lines, line) end

**0         fragment_data[fragment.hash] = {
              index = i,
              aliases = fragment.aliases,
              source = fragment.source,
              content = fragment.content,
              datetime = fragment.datetime,
              start_line = current_line,
            }
**0         for j = 0, 5 do line_to_fragment[current_line + j] = fragment.hash end
**0         current_line = current_line + 6
          end
        end
      end

**0   api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)
**0   styles.setup_highlights()
**0   styles.setup_buffer_syntax(bufnr)
**0   vim.b[bufnr].line_to_fragment = line_to_fragment
**0   vim.b[bufnr].fragment_data = fragment_data
**0   vim.b[bufnr].fragments = fragments
    end

    -- Setup keymaps for the fragment management buffer
  1 function M.setup_fragments_keymaps(bufnr, manager_module)
**0   manager_module = manager_module or M

      local function set_keymap(mode, lhs, rhs)
**0     api.nvim_buf_set_keymap(bufnr, mode, lhs, rhs, { noremap = true, silent = true })
      end

**0   set_keymap('n', 'v', string.format([[<Cmd>lua require('%s').view_fragment_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'a', string.format([[<Cmd>lua require('%s').set_alias_for_fragment_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'r', string.format([[<Cmd>lua require('%s').remove_alias_from_fragment_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 't', string.format([[<Cmd>lua require('%s').toggle_fragments_view(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'n', string.format([[<Cmd>lua require('%s').add_file_fragment(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'g', string.format([[<Cmd>lua require('%s').add_github_fragment_from_manager(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'p', string.format([[<Cmd>lua require('%s').prompt_with_fragment_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
    end

    -- Action functions called by keymaps (now accept bufnr)
  1 function M.view_fragment_under_cursor(bufnr)
**0   local fragment_hash, fragment_info = M.get_fragment_info_under_cursor(bufnr)
**0   if not fragment_hash then return end
**0   fragments_view.view_fragment(fragment_info.content, fragment_info.source)
    end

  1 function M.set_alias_for_fragment_under_cursor(bufnr)
  1   print("Setting alias")
  1   local fragment_hash, _ = M.get_fragment_info_under_cursor(bufnr)
  1   if not fragment_hash then return end
  1   print("Got fragment hash")

  2   fragments_view.get_alias(function(alias)
  1     if not alias or alias == "" then return end
  1     print("Got alias")
  1     if llm_cli.run_llm_command('fragments alias set ' .. fragment_hash .. ' ' .. alias) then
  1       print("Alias set")
  1       vim.notify("Alias set: " .. alias .. " -> " .. fragment_hash:sub(1, 8), vim.log.levels.INFO)
  1       cache.invalidate('fragments')
  1       require('llm.ui.unified_manager').switch_view("Fragments")
        else
**0       vim.notify("Failed to set alias", vim.log.levels.ERROR)
        end
      end)
    end

  1 function M.remove_alias_from_fragment_under_cursor(bufnr)
  1   local fragment_hash, fragment_info = M.get_fragment_info_under_cursor(bufnr)
  1   if not fragment_hash then return end
  1   if #fragment_info.aliases == 0 then
**0     vim.notify("Fragment has no aliases", vim.log.levels.WARN)
**0     return
      end

  1   local alias_to_remove = fragment_info.aliases[1]
  1   if #fragment_info.aliases > 1 then
**0     fragments_view.select_alias_to_remove(fragment_info.aliases, function(selected_alias)
**0       if not selected_alias then return end
**0       M.confirm_and_remove_alias(selected_alias)
        end)
      else
  1     M.confirm_and_remove_alias(alias_to_remove)
      end
    end

  1 function M.confirm_and_remove_alias(alias)
  2   fragments_view.confirm_remove_alias(alias, function(confirmed)
  1     if not confirmed then return end
  1     if llm_cli.run_llm_command('fragments alias remove ' .. alias) then
  1       vim.notify("Alias removed: " .. alias, vim.log.levels.INFO)
  1       cache.invalidate('fragments')
  1       require('llm.ui.unified_manager').switch_view("Fragments")
        else
**0       vim.notify("Failed to remove alias", vim.log.levels.ERROR)
        end
      end)
    end

  1 function M.toggle_fragments_view(bufnr)
**0   _G.llm_fragments_show_all = not (_G.llm_fragments_show_all or false)
**0   require('llm.ui.unified_manager').switch_view("Fragments")
    end

  1 function M.add_file_fragment(bufnr)
  2     fragments_view.select_file(function(file_path)
  1         if not file_path then return end
  1         llm_cli.run_llm_command('fragments store ' .. file_path)
  1         cache.invalidate('fragments')
  1         require('llm.ui.unified_manager').switch_view("Fragments")
        end)
    end

  1 function M.add_github_fragment_from_manager(bufnr)
  2     fragments_view.get_github_url(function(url)
  1         if not url then return end
  1         llm_cli.run_llm_command('fragments store ' .. url)
  1         cache.invalidate('fragments')
  1         require('llm.ui.unified_manager').switch_view("Fragments")
        end)
    end

  1 function M.get_fragment_info_under_cursor(bufnr)
**0   local current_line = api.nvim_win_get_cursor(0)[1]
**0   local line_to_fragment = vim.b[bufnr].line_to_fragment
**0   local fragment_data = vim.b[bufnr].fragment_data
**0   if not line_to_fragment or not fragment_data then
**0     vim.notify("Buffer data missing", vim.log.levels.ERROR)
**0     return nil, nil
      end
**0   local fragment_hash = line_to_fragment[current_line]
**0   if fragment_hash and fragment_data[fragment_hash] then
**0     return fragment_hash, fragment_data[fragment_hash]
      end
**0   return nil, nil
    end

  1 function M.manage_fragments(show_all)
**0   _G.llm_fragments_show_all = show_all or false
**0   require('llm.ui.unified_manager').open_specific_manager("Fragments")
    end

  1 function M.prompt_with_fragment_under_cursor(bufnr)
**0   local fragment_hash, fragment_info = M.get_fragment_info_under_cursor(bufnr)
**0   if not fragment_hash then
**0     vim.notify("No fragment selected", vim.log.levels.WARN)
**0     return
      end

**0   local fragment_identifier = fragment_hash

**0   api.nvim_win_close(0, true)

**0   fragments_view.get_prompt(function(input_prompt)
**0     if not input_prompt or input_prompt == "" then
**0       vim.notify("Prompt cannot be empty", vim.log.levels.ERROR)
**0       return
        end
**0     require('llm').prompt(input_prompt, { fragment_identifier })
      end)
    end

  1 M.__name = 'llm.managers.fragments_manager'

  1 return M

==============================================================================
lua/llm/managers/keys_manager.lua
==============================================================================
    -- llm/managers/keys_manager.lua - API key management for llm-nvim
    -- License: Apache 2.0

 10 local M = {}

    -- Forward declarations
 10 local api = vim.api
 10 local llm_cli = require('llm.core.data.llm_cli')
 10 local cache = require('llm.core.data.cache')
 10 local keys_view = require('llm.ui.views.keys_view')
 10 local styles = require('llm.ui.styles')

    -- Get stored API keys from llm CLI
 10 function M.get_stored_keys()
  1     local cached_keys = cache.get('keys')
  1     if cached_keys then
**0         return cached_keys
        end

  1     local keys_json = llm_cli.run_llm_command('keys list --json')
  1     local keys = vim.fn.json_decode(keys_json)
  1     cache.set('keys', keys)
  1     return keys
    end

    -- Check if an API key is set
 10 function M.is_key_set(key_name)
  2   local stored_keys = M.get_stored_keys()
  2   for _, key in ipairs(stored_keys) do
  1     if key.name == key_name then
  1       return true
        end
      end
  1   return false
    end

    -- Set an API key by directly modifying the keys.json file
 10 function M.set_api_key(key_name, key_value)
  1     local result = llm_cli.run_llm_command('keys set ' .. key_name .. ' ' .. key_value)
  1     cache.invalidate('keys')
  1     return result ~= nil
    end

    -- Remove an API key by directly modifying the keys.json file
 10 function M.remove_api_key(key_name)
  1     local result = llm_cli.run_llm_command('keys remove ' .. key_name)
  1     cache.invalidate('keys')
  1     return result ~= nil
    end

    -- Populate the buffer with key management content
 10 function M.populate_keys_buffer(bufnr)
**0   local all_stored_keys_list = M.get_stored_keys()
**0   local stored_keys_set = {}
**0   for _, key in ipairs(all_stored_keys_list) do stored_keys_set[key.name] = true end

**0   local lines = {
        "# API Key Management",
        "",
        "Navigate: [M]odels [P]lugins [F]ragments [T]emplates [S]chemas",
        "Actions: [s]et key [r]emove key [A]dd custom [q]uit",
        "──────────────────────────────────────────────────────────────",
        "",
        "## Available Providers:",
        ""
      }

**0   local predefined_providers_list = {
        "openai", "anthropic", "mistral", "gemini", "groq", "perplexity",
        "cohere", "replicate", "anyscale", "together", "deepseek", "fireworks",
        "aws", "azure",
      }
**0   local predefined_providers_set = {}
**0   for _, p_name in ipairs(predefined_providers_list) do predefined_providers_set[p_name] = true end

**0   local key_data = {}
**0   local line_to_provider = {}
**0   local current_line = #lines + 1

**0   for _, provider_name in ipairs(predefined_providers_list) do
**0     local is_set = stored_keys_set[provider_name] or false
**0     local status = is_set and "✓" or " "
**0     local line = string.format("[%s] %s", status, provider_name)
**0     table.insert(lines, line)
**0     key_data[provider_name] = { line = current_line, is_set = is_set }
**0     line_to_provider[current_line] = provider_name
**0     current_line = current_line + 1
      end

**0   table.insert(lines, "")

**0   local custom_keys_to_display = {}
**0   for _, stored_key in ipairs(all_stored_keys_list) do
**0     if not predefined_providers_set[stored_key.name] then
**0       table.insert(custom_keys_to_display, stored_key.name)
        end
      end
**0   table.sort(custom_keys_to_display)

**0   if #custom_keys_to_display > 0 then
**0     table.insert(lines, "## Custom Keys:")
**0     table.insert(lines, "")
**0     for _, custom_key_name in ipairs(custom_keys_to_display) do
**0       local line = string.format("[✓] %s", custom_key_name)
**0       table.insert(lines, line)
**0       key_data[custom_key_name] = { line = current_line, is_set = true }
**0       line_to_provider[current_line] = custom_key_name
**0       current_line = current_line + 1
        end
**0     table.insert(lines, "")
      end

**0   api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)
**0   styles.setup_highlights()
**0   styles.setup_buffer_syntax(bufnr)
**0   vim.b[bufnr].line_to_provider = line_to_provider
**0   vim.b[bufnr].key_data = key_data
**0   vim.b[bufnr].stored_keys_set = stored_keys_set
    end

    -- Setup keymaps for the key management buffer
 10 function M.setup_keys_keymaps(bufnr, manager_module)
**0   manager_module = manager_module or M

      local function set_keymap(mode, lhs, rhs)
**0     api.nvim_buf_set_keymap(bufnr, mode, lhs, rhs, { noremap = true, silent = true })
      end

**0   set_keymap('n', 's', string.format([[<Cmd>lua require('%s').set_key_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'r', string.format([[<Cmd>lua require('%s').remove_key_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'A', string.format([[<Cmd>lua require('%s').add_new_custom_key_interactive(%d)<CR>]], manager_module.__name, bufnr))
    end

 10 function M.add_new_custom_key_interactive(bufnr)
**0   keys_view.get_custom_key_name(function(custom_name)
**0     if not custom_name or custom_name == "" then
**0       vim.notify("Custom key name cannot be empty. Aborted.", vim.log.levels.WARN)
**0       return
        end

**0     keys_view.get_api_key(custom_name, function(key_value)
**0       if not key_value or key_value == "" then
**0         vim.notify("API key value cannot be empty. Aborted.", vim.log.levels.WARN)
**0         return
          end

**0       if M.set_api_key(custom_name, key_value) then
**0         vim.notify("Successfully set key for '" .. custom_name .. "'", vim.log.levels.INFO)
**0         require('llm.ui.unified_manager').switch_view("Keys")
          else
**0         vim.notify("Failed to set key for '" .. custom_name .. "'. See previous errors for details.", vim.log.levels.ERROR)
          end
        end)
      end)
    end

 10 function M.set_key_under_cursor(bufnr)
**0   local provider_name, _ = M.get_provider_info_under_cursor(bufnr)
**0   if not provider_name then return end

**0   keys_view.get_api_key(provider_name, function(key_value)
**0     if not key_value or key_value == "" then
**0       vim.notify("API key value cannot be empty. Aborted for " .. provider_name .. ".", vim.log.levels.WARN)
**0       return
        end
**0     if M.set_api_key(provider_name, key_value) then
**0       vim.notify("Key for '" .. provider_name .. "' set", vim.log.levels.INFO)
**0       require('llm.ui.unified_manager').switch_view("Keys")
        else
**0       vim.notify("Failed to set key for '" .. provider_name .. "'.", vim.log.levels.ERROR)
        end
      end)
    end

 10 function M.remove_key_under_cursor(bufnr)
**0   local provider_name, key_info = M.get_provider_info_under_cursor(bufnr)
**0   if not provider_name or provider_name == "+" then return end

**0   local stored_keys_set = vim.b[bufnr].stored_keys_set
**0   if not stored_keys_set[provider_name] then
**0     vim.notify("No key found for '" .. provider_name .. "'", vim.log.levels.WARN)
**0     return
      end

**0   keys_view.confirm_remove_key(provider_name, function()
**0     if M.remove_api_key(provider_name) then
**0       vim.notify("Key for '" .. provider_name .. "' removed", vim.log.levels.INFO)
**0       require('llm.ui.unified_manager').switch_view("Keys")
        else
**0       vim.notify("Failed to remove key for '" .. provider_name .. "'", vim.log.levels.ERROR)
        end
      end)
    end

 10 function M.get_provider_info_under_cursor(bufnr)
**0   local current_line = api.nvim_win_get_cursor(0)[1]
**0   local line_to_provider = vim.b[bufnr].line_to_provider
**0   local key_data = vim.b[bufnr].key_data
**0   if not line_to_provider or not key_data then
**0     vim.notify("Buffer data missing", vim.log.levels.ERROR)
**0     return nil, nil
      end
**0   local provider_name = line_to_provider[current_line]
**0   if provider_name == "+" then
**0     return "+", nil
**0   elseif provider_name and key_data[provider_name] then
**0     return provider_name, key_data[provider_name]
      end
**0   return nil, nil
    end

 10 function M.manage_keys()
**0   require('llm.ui.unified_manager').open_specific_manager("Keys")
    end

 10 M.__name = 'llm.managers.keys_manager'

 10 return M

==============================================================================
lua/llm/managers/models_io.lua
==============================================================================
    -- llm/managers/models_io.lua - I/O functions for model management
    -- License: Apache 2.0

  9 local M = {}

  9 local llm_cli = require('llm.core.data.llm_cli')

  9 function M.get_models_from_cli()
  1     return llm_cli.run_llm_command("models list --json")
    end

  9 function M.get_default_model_from_cli()
  1     return llm_cli.run_llm_command("default")
    end

  9 function M.set_default_model_in_cli(model_name)
  1     return llm_cli.run_llm_command(string.format('default %s', model_name))
    end

  9 function M.get_aliases_from_cli()
  1     return llm_cli.run_llm_command("aliases list --json")
    end

  9 function M.set_alias_in_cli(alias, model)
  1     return llm_cli.run_llm_command(string.format('aliases set %s %s', alias, model))
    end

  9 function M.remove_alias_in_cli(alias)
  1     local escaped_alias = string.format("'%s'", alias:gsub("'", "'\\''"))
  1     local cmd = string.format("aliases remove %s", escaped_alias)
  1     return llm_cli.run_llm_command(cmd)
    end

  9 return M

==============================================================================
lua/llm/managers/models_manager.lua
==============================================================================
    -- llm/managers/models_manager.lua - Model management functionality
    -- License: Apache 2.0

  3 local errors = require('llm.errors')
  3 local M = {}

    -- Forward declarations
  3 local api = vim.api
  3 local fn = vim.fn
  3 local llm_cli = require('llm.core.data.llm_cli')
  3 local cache = require('llm.core.data.cache')
  3 local config = require('llm.config')
  3 local styles = require('llm.ui.styles')


  3 local custom_openai = require('llm.managers.custom_openai')
  3 local models_io = require('llm.managers.models_io')
  3 local models_view = require('llm.ui.views.models_view')

  3 function M.set_custom_openai(new_custom_openai)
**0   custom_openai = new_custom_openai
    end

  3 function M.set_models_io(new_models_io)
**0   models_io = new_models_io
    end

    -- Add pattern escape function to vim namespace if it doesn't exist
  3 if not vim.pesc then
  3   vim.pesc = function(s)
**0     return string.gsub(s, "[%(%)%.%+%-%*%?%[%]%^%$%%]", "%%%1")
      end
    end

    -- Get custom OpenAI models
  3 function M.get_custom_openai_models()
**0   return custom_openai.custom_openai_models
    end

    -- Force reload custom OpenAI models
  3 function M.reload_custom_openai_models()
**0   return custom_openai.load_custom_openai_models()
    end

    -- Get available providers with valid API keys
  3 function M.get_available_providers()
**0   local keys_manager = require('llm.managers.keys_manager')
**0   local plugins_manager = require('llm.managers.plugins_manager')

**0   return {
        -- OpenAI only requires the API key, not a plugin
        OpenAI = keys_manager.is_key_set("openai"),
        Anthropic = keys_manager.is_key_set("anthropic"),
        Mistral = keys_manager.is_key_set("mistral"),
        Gemini = keys_manager.is_key_set("gemini"),                 -- Corrected key name from "google" to "gemini"
        Groq = keys_manager.is_key_set("groq"),
        Ollama = plugins_manager.is_plugin_installed("llm-ollama"), -- Corrected plugin name from "ollama" to "llm-ollama"
        -- Local models are always available
**0     Local = true
      }
    end

    -- Check if a specific model is available (used when setting default)
  3 function M.is_model_available(model_line)
  2   local providers = M.get_available_providers()
  2   local model_name = M.extract_model_name(model_line)

  2   if config.get("debug") then
**0     vim.notify("Checking if model is available: " .. model_line, vim.log.levels.DEBUG)
**0     vim.notify("Extracted model name: " .. model_name, vim.log.levels.DEBUG)
      end

      -- Check for custom OpenAI models (from extra-openai-models.yaml)
  2   if (model_line:match("OpenAI") and model_line:match("%(custom%)")) or
  2       model_line:match("^Custom OpenAI:") or
  2       model_line:match("^Azure OpenAI:") then
**0     if config.get("debug") then
**0       vim.notify("Checking custom model availability: " .. model_name, vim.log.levels.INFO)
        end
        -- For custom models, check validity using the dedicated function and the extracted name/id
**0     return custom_openai.is_custom_openai_model_valid(model_name)
  2   elseif model_line:match("OpenAI") then
        -- Check if this standard-looking OpenAI model is actually a custom one
  2     if custom_openai.is_custom_openai_model_valid(model_name) then
**0       if config.get("debug") then
**0         vim.notify("Identified standard OpenAI line as custom model: " .. model_name, vim.log.levels.INFO)
          end
**0       return true -- Validity is checked by is_custom_openai_model_valid
        end
        -- Regular OpenAI only requires the API key
  2     return providers.OpenAI
**0   elseif model_line:match("Anthropic") then
**0     return providers.Anthropic
**0   elseif model_line:match("Mistral") then
**0     return providers.Mistral
**0   elseif model_line:match("Gemini") then
**0     return providers.Gemini
**0   elseif model_line:match("Groq") then
**0     return providers.Groq
**0   elseif model_line:match("ollama") then
**0     return providers.Ollama
**0   elseif model_line:match("gguf") or model_line:match("local") then
**0     return providers.Local
      end

      -- Default to true if we can't determine requirements
**0   return true
    end

    -- Get available models from llm CLI
  3 function M.get_available_models()
  3   local cached_models = cache.get('models')
  3   if cached_models then
  1     vim.notify("DEBUG: Cache hit for models at " .. os.time(), vim.log.levels.DEBUG)
  1     return cached_models
      end

  2   vim.notify("DEBUG: Cache miss for models. Running llm models list at " .. os.time(), vim.log.levels.DEBUG)
  2   local models_json = llm_cli.run_llm_command('models list')
  2   vim.notify("DEBUG: llm models list command finished at " .. os.time(), vim.log.levels.DEBUG)
  2   if not models_json then return {} end
  2   local models = {}
  6   for line in models_json:gmatch("[^\n]+") do
  4     if not line:match("^%-%-") and line ~= "" and not line:match("^Models:") and not line:match("^Default:") then
          local provider, model_id
          -- Try to match known prefixes first
  4       if line:match("^OpenAI Chat: ") then
**0         provider = "OpenAI Chat"
**0         model_id = line:gsub("^OpenAI Chat: ", "")
  4       elseif line:match("^OpenAI Completion: ") then
**0         provider = "OpenAI Completion"
**0         model_id = line:gsub("^OpenAI Completion: ", "")
  4       elseif line:match("^Anthropic Messages: ") then
**0         provider = "Anthropic Messages"
**0         model_id = line:gsub("^Anthropic Messages: ", "")
  4       elseif line:match("^DeepSeek: ") then
**0         provider = "DeepSeek"
**0         model_id = line:gsub("^DeepSeek: ", "")
  4       elseif line:match("^GeminiPro: ") then
**0         provider = "GeminiPro"
**0         model_id = line:gsub("^GeminiPro: ", "")
  4       elseif line:match("^Ollama: ") then
**0         provider = "Ollama"
**0         model_id = line:gsub("^Ollama: ", "")
          else
            -- Fallback to generic provider: model_id parsing
  4         provider, model_id = line:match("([^:]+):%s*(.+)")
          end

  4       if provider and model_id then
**0         local clean_model_id = model_id:gsub("%s*%s*%(aliases.-%)", "")
**0         table.insert(models, { provider = provider, id = clean_model_id, name = clean_model_id })
          else
            -- Handle lines without a provider or unparseable lines
  4         table.insert(models, { provider = "Other", id = line, name = line })
          end
        end
      end
  2   cache.set('models', models)
  2   return models
    end

    -- Extract model name from the full model line
  3 function M.extract_model_name(model_line)
  2   if not model_line or model_line == "" then
**0     if config.get("debug") then
**0       vim.notify("extract_model_name called with empty model_line", vim.log.levels.DEBUG)
        end
**0     return ""
      end

      -- Handle custom OpenAI models specially
  2   if model_line:match("OpenAI") and model_line:match("%(custom%)") then
**0     local model_name = model_line:match(": ([^%(]+)")
**0     if model_name then
          -- Trim whitespace
**0       model_name = model_name:match("^%s*(.-)%s*$")
**0       return model_name
        end
      end

      -- Handle "Custom OpenAI:" format as well
  2   if model_line:match("^Custom OpenAI:") then
**0     local model_name = model_line:match("^Custom OpenAI:%s*(.+)")
**0     if model_name then
          -- Trim whitespace
**0       model_name = model_name:match("^%s*(.-)%s*$")
**0       return model_name
        end
      end

      -- Extract the actual model name (after the provider type)
  2   local model_name = model_line:match(": ([^%(]+)")
  2   if model_name then
        -- Trim whitespace
  2     model_name = model_name:match("^%s*(.-)%s*$")
  2     return model_name
      end

      -- Try to match format like "Anthropic Messages: anthropic/claude-3-opus-20240229"
**0   model_name = model_line:match(": ([^%s]+)")
**0   if model_name then
**0     return model_name
      end

      -- Fallback to the full line if no patterns match
      -- This ensures we can still find the model in the list
**0   return model_line
    end

    -- Set the default model using llm CLI
  3 function M.set_default_model(model_name)
  1   local result = models_io.set_default_model_in_cli(model_name)
  1   if result then
  1     cache.invalidate('models')
      end
  1   return result
    end

    -- Get model aliases from llm CLI
  3 function M.get_model_aliases()
**0   local cached_aliases = cache.get('aliases')
**0   if cached_aliases then
**0     vim.notify("DEBUG: Cache hit for aliases at " .. os.time(), vim.log.levels.DEBUG)
**0     return cached_aliases
      end

**0   vim.notify("DEBUG: Cache miss for aliases. Running llm aliases list --json at " .. os.time(), vim.log.levels.DEBUG)
**0   local aliases_json = llm_cli.run_llm_command('aliases list --json')
**0   vim.notify("DEBUG: llm aliases list --json command finished at " .. os.time(), vim.log.levels.DEBUG)
**0   if not aliases_json then return {} end
**0   local aliases = vim.fn.json_decode(aliases_json)
**0   cache.set('aliases', aliases)
**0   return aliases
    end

    -- Set a model alias using llm CLI
  3 function M.set_model_alias(alias, model)
  1   local result = models_io.set_alias_in_cli(alias, model)
  1   if result then
  1     cache.invalidate('aliases')
      end
  1   return result
    end

    -- Remove a model alias by directly modifying the aliases.json file
  3 function M.remove_model_alias(alias)
  1   local result = models_io.remove_alias_in_cli(alias)
  1   if result then
  1     cache.invalidate('aliases')
      end
  1   return result
    end

    -- Select a model to use (now primarily for direct selection, not management)
  3 function M.select_model()
**0   local models = M.get_available_models()

**0   if #models == 0 then
**0     api.nvim_err_writeln("No models found. Make sure llm is properly configured.")
**0     return
      end

**0   models_view.select_model(models, function(choice)
**0     if not choice then return end
**0     local model_name = M.extract_model_name(choice.id)
**0     config.options.model = model_name
**0     vim.notify("Model set to: " .. model_name, vim.log.levels.INFO)
      end)
    end

    -- Populate the buffer with model management content
    -- Generate the list of models for the management buffer
  3 function M.generate_models_list()
**0   local models = M.get_available_models()
**0   if #models == 0 then
**0     return {
**0       lines = {
            "# Model Management - No Models Found",
            "",
            "No models found. Make sure llm CLI is properly installed and configured.",
            "Use the [K]eys manager to set up API keys for your providers.",
            "Or use the [P]lugins manager to install required plugins.",
            "",
            "Press [q]uit or use navigation keys ([P]lugins, [K]eys, etc.)"
          },
          line_to_model_id = {},
**0       model_data = {}
        }
      end

**0   local aliases = M.get_model_aliases()
**0   local default_model_output = llm_cli.run_llm_command('models default')
**0   local default_model = ""
**0   if default_model_output and default_model_output ~= "" then
**0     default_model = default_model_output:match("Default model: (.+)") or default_model_output:match("(.+)")
      end

**0   local lines = {
        "# Model Management",
        "",
        "Navigate: [P]lugins [K]eys [F]ragments [T]emplates [S]chemas",
        "Actions: [s]et default [a]dd alias [r]emove alias [c]ustom model [q]uit", -- Updated actions
        "──────────────────────────────────────────────────────────────",
        ""
      }
      -- Create reverse lookup and group models
**0   local providers = {
        ["OpenAI"] = {},
        ["Custom OpenAI"] = {},
        ["Anthropic Messages"] = {},
        ["Mistral"] = {},
        ["GeminiPro"] = {},
        ["DeepSeek"] = {},
        ["Groq"] = {},
        ["Local Models"] = {},
        ["Ollama"] = {},
**0     ["Other"] = {}
      }
**0   local processed_custom_model_ids = {} -- Set to track added custom model IDs

      -- Ensure custom OpenAI models are loaded before processing
**0   custom_openai.load_custom_openai_models()
**0   local model_to_aliases = {}
**0   for alias, model in pairs(aliases) do
**0     if not model_to_aliases[model] then model_to_aliases[model] = {} end
**0     table.insert(model_to_aliases[model], alias)
      end

**0   for _, model in ipairs(models) do
**0     local extracted_name = model.id -- This is the name/id part of the line
**0     local model_id = model.id       -- Default model_id to extracted name
**0     local model_name = model.name   -- Default model_name to extracted name
**0     local is_custom = false
        local custom_model_info = nil

        -- Determine provider and potentially find custom model info
**0     local provider_key = model.provider or "Other"
**0     if provider_key == "OpenAI Chat" or provider_key == "OpenAI Completion" then
**0       provider_key = "OpenAI"
        end

**0     if provider_key == "Custom OpenAI" or custom_openai.is_custom_openai_model_valid(model_id) then
**0       is_custom = true
**0       provider_key = "Custom OpenAI"
          -- Find the corresponding custom model data using the extracted name/id
          -- Prioritize matching the extracted name directly to a model_id first
**0       if custom_openai.custom_openai_models[extracted_name] then
**0         custom_model_info = custom_openai.custom_openai_models[extracted_name]
**0         model_id = custom_model_info.model_id
**0         model_name = custom_model_info.model_name
          else
            -- Fallback: Iterate to find match by model_name if ID didn't match
**0         for id, info in pairs(custom_openai.custom_openai_models) do
**0           if info.model_name == extracted_name then
**0             custom_model_info = info
**0             model_id = info.model_id
**0             model_name = info.model_name
                break
              end
            end
          end
          -- If still no match, something is wrong, but proceed with extracted values
**0       if not custom_model_info then
**0         if config.get("debug") then
**0           vim.notify("Could not find custom model info for: " .. extracted_name, vim.log.levels.WARN)
            end
            -- Keep model_id and model_name as extracted_name
          end
        end

        -- Create the entry for this model
**0     local entry = {
          model_id = model_id,
          model_name = model_name,
          full_line = is_custom and ("Custom OpenAI: " .. model_name .. " (" .. model_id .. ")") or model.id, -- The original line from `llm models` or constructed for custom
          is_default = (model_id == default_model),
          is_custom = is_custom,
          aliases = model_to_aliases[model_id] or {}, -- Check aliases ONLY by model_id
**0       provider = provider_key
        }

        -- Check for duplicates before adding to the provider list
**0     if not (is_custom and processed_custom_model_ids[model_id]) then
**0       if is_custom then
**0         processed_custom_model_ids[model_id] = true -- Mark this ID as processed
          end

**0       if not providers[provider_key] then
**0         providers[provider_key] = {}
          end
**0       table.insert(providers[provider_key], entry)
**0     elseif config.get("debug") then
**0       vim.notify("Skipping duplicate custom model entry for ID: " .. model_id, vim.log.levels.DEBUG)
        end
      end

**0   local model_data = {}       -- Stores detailed info keyed by model_id
**0   local line_to_model_id = {} -- Maps buffer line number to model_id
**0   local current_line = #lines + 1
      -- Add content to buffer
**0   local provider_keys = {}
**0   for key, _ in pairs(providers) do
**0     table.insert(provider_keys, key)
      end
**0   table.sort(provider_keys)

**0   for _, provider in ipairs(provider_keys) do
**0     local provider_models = providers[provider]
**0     if #provider_models > 0 then
**0       table.insert(lines, provider)
**0       table.insert(lines, string.rep("─", #provider))
**0       current_line = current_line + 2
          -- Sort models within the provider group based on the display name (model_name)
**0       table.sort(provider_models, function(a, b) return a.model_name < b.model_name end)

**0       for _, model_entry in ipairs(provider_models) do
**0         local status = model_entry.is_default and "✓" or " "
**0         local alias_text = #model_entry.aliases > 0 and " (aliases: " .. table.concat(model_entry.aliases, ", ") .. ")" or ""
            -- Display model_name in the list
**0         local display_line_part = model_entry.model_name
**0         local provider_prefix = model_entry.provider .. ":"
**0         local line = string.format("[%s] %s %s%s", status, provider_prefix, display_line_part, alias_text)

**0         table.insert(lines, line)
            -- Store data keyed by model_id
**0         model_data[model_entry.model_id] = {
              line = current_line,
              is_default = model_entry.is_default,
              is_custom = model_entry.is_custom,
              full_line = model_entry.full_line,   -- Store original line for context if needed
              model_name = model_entry.model_name, -- Store model name
**0           aliases = model_entry.aliases
            }
            -- Map buffer line number to model_id
**0         line_to_model_id[current_line] = model_entry.model_id
**0         current_line = current_line + 1
          end
**0       table.insert(lines, "")
**0       current_line = current_line + 1
        end
      end
**0   table.insert(lines, "")

**0   return {
        lines = lines,
        line_to_model_id = line_to_model_id,
**0     model_data = model_data
      }
    end

    -- Populate the buffer with model management content
  3 function M.populate_models_buffer(bufnr)
**0   local data = M.generate_models_list()

**0   api.nvim_buf_set_lines(bufnr, 0, -1, false, data.lines)
**0   styles.setup_highlights()
**0   styles.setup_buffer_syntax(bufnr) -- Use styles module

      -- Store lookup tables in buffer variables for keymaps
**0   vim.b[bufnr].line_to_model_id = data.line_to_model_id
**0   vim.b[bufnr].model_data = data.model_data

**0   return data.line_to_model_id, data.model_data -- Return for direct use if needed
    end

    -- Setup keymaps for the model management buffer
  3 function M.setup_models_keymaps(bufnr, manager_module)
**0   manager_module = manager_module or M -- Allow passing self for testing/modularity

      local function set_keymap(mode, lhs, rhs)
**0     api.nvim_buf_set_keymap(bufnr, mode, lhs, rhs, { noremap = true, silent = true })
      end

      -- Set model under cursor as default
**0   set_keymap('n', 's',
**0     string.format([[<Cmd>lua require('%s').set_model_under_cursor(%d)<CR>]],
**0       manager_module.__name or 'llm.managers.models_manager', bufnr))

      -- Set alias for model under cursor
**0   set_keymap('n', 'a',
**0     string.format([[<Cmd>lua require('%s').set_alias_for_model_under_cursor(%d)<CR>]],
**0       manager_module.__name or 'llm.managers.models_manager', bufnr))

      -- Remove alias for model under cursor
**0   set_keymap('n', 'r',
**0     string.format([[<Cmd>lua require('%s').remove_alias_for_model_under_cursor(%d)<CR>]],
**0       manager_module.__name or 'llm.managers.models_manager', bufnr))

**0   set_keymap('n', 'c', -- New keymap for adding custom OpenAI model
**0     string.format([[<Cmd>lua require('%s').add_custom_openai_model_interactive(%d)<CR>]],
**0       manager_module.__name or 'llm.managers.models_manager', bufnr))
    end

    -- Action functions called by keymaps (now accept bufnr)

    -- Function to add a new custom OpenAI model via interactive input
  3 function M.add_custom_openai_model_interactive(bufnr)
**0   models_view.get_custom_model_details(function(details)
**0     local success, err_msg = custom_openai.add_custom_openai_model(details)
**0     if success then
**0       custom_openai.load_custom_openai_models() -- Reload models
**0       vim.notify("Custom OpenAI model '" .. (details.model_name or details.model_id) .. "' added successfully.",
**0         vim.log.levels.INFO)
**0       require('llm.ui.unified_manager').switch_view("Models")
        else
**0       vim.notify("Failed to add custom OpenAI model: " .. (err_msg or "Unknown error"), vim.log.levels.ERROR)
        end
**0     vim.cmd('stopinsert') -- Ensure normal mode
      end)
    end

    -- Sets the model under the cursor as the default LLM model.
  3 function M.set_default_model_logic(model_id, model_info)
**0   if not model_id or not model_info then
**0     return { success = false, message = "No model info found" }
      end

**0   local display_name = model_info.model_name or model_id

**0   if model_info.is_default then
**0     return { success = false, message = "Model '" .. display_name .. "' is already the default" }
      end

**0   local check_identifier = model_info.is_custom and model_id or model_info.full_line
**0   if not M.is_model_available(check_identifier) then
**0     local provider = "unknown"
**0     if model_info.is_custom then
**0       provider = "Custom OpenAI/Azure"
**0     elseif model_info.full_line:match("OpenAI") then
**0       provider = "OpenAI"
**0     elseif model_info.full_line:match("Anthropic") then
**0       provider = "Anthropic"
**0     elseif model_info.full_line:match("Mistral") then
**0       provider = "Mistral"
**0     elseif model_info.full_line:match("Gemini") then
**0       provider = "Gemini"
**0     elseif model_info.full_line:match("Groq") then
**0       provider = "Groq"
**0     elseif model_info.full_line:match("ollama") then
**0       provider = "Ollama"
        end
**0     return {
          success = false,
**0       message = "Cannot set as default: " ..
**0           provider .. " requirements not met (API key/plugin/config)"
        }
      end

**0   if M.set_default_model(model_id) then
**0     config.options.model = model_id
**0     return { success = true, message = "Default model set to: " .. display_name }
      else
**0     return { success = false, message = "Failed to set default model via llm CLI" }
      end
    end

    -- Sets the model under the cursor as the default LLM model.
  3 function M.set_model_under_cursor(bufnr)
**0   local model_id, model_info = M.get_model_info_under_cursor(bufnr)
**0   local result = M.set_default_model_logic(model_id, model_info)

**0   if result.success then
**0     vim.notify(result.message, vim.log.levels.INFO)
**0     require('llm.ui.unified_manager').switch_view("Models") -- Refresh view
      else
**0     vim.notify(result.message, vim.log.levels.ERROR)
      end
    end

    -- Sets an alias for the model under the cursor.
  3 function M.set_alias_for_model_under_cursor(bufnr)
**0   local model_id, model_info = M.get_model_info_under_cursor(bufnr)
**0   if not model_id or not model_info then
**0     if config.get("debug") then
**0       vim.notify("set_alias_for_model_under_cursor: no model_id or model_info", vim.log.levels.DEBUG)
        end
**0     return
      end

**0   if config.get("debug") then
**0     vim.notify("set_alias_for_model_under_cursor: model_id=" .. model_id, vim.log.levels.DEBUG)
      end

**0   local display_name = model_info.model_name or model_id

**0   models_view.get_alias(display_name, function(alias)
**0     if not alias or alias == "" then
**0       vim.notify("Alias cannot be empty", vim.log.levels.WARN)
**0       return
        end

**0     if M.set_model_alias(alias, model_id) then
**0       vim.notify("Alias set: " .. alias .. " -> " .. display_name .. " (ID: " .. model_id .. ")", vim.log.levels.INFO)
**0       vim.cmd('stopinsert')
**0       require('llm.ui.unified_manager').switch_view("Models")
        else
**0       vim.notify("Failed to set alias via llm CLI", vim.log.levels.ERROR)
**0       vim.cmd('stopinsert')
        end
      end)
    end

    -- Removes an alias associated with the model under the cursor.
  3 function M.remove_alias_for_model_under_cursor(bufnr)
**0   local model_id, model_info = M.get_model_info_under_cursor(bufnr)
**0   if not model_id or not model_info then return end -- Exit if no model info

**0   local display_name = model_info.model_name or model_id

**0   if not model_info.aliases or #model_info.aliases == 0 then
**0     vim.notify("No aliases found for model '" .. display_name .. "'", vim.log.levels.WARN)
**0     return
      end

**0   models_view.select_alias_to_remove(model_info.aliases, function(alias)
**0     if not alias then return end
**0     models_view.confirm_remove_alias(alias, function()
**0       if M.remove_model_alias(alias) then
**0         vim.notify("Alias removed: " .. alias, vim.log.levels.INFO)
**0         require('llm.ui.unified_manager').switch_view("Models")
          else
**0         vim.notify("Failed to remove alias '" .. alias .. "'", vim.log.levels.ERROR)
          end
        end)
      end
      )
    end

    -- Helper to get model info (ID and data) from buffer variables (Duplicate of local function, keep for external calls if needed)
  3 function M.get_model_info_under_cursor(bufnr)
**0   local current_line = api.nvim_win_get_cursor(0)[1]
**0   local line_to_model_id = vim.b[bufnr].line_to_model_id
**0   local model_data = vim.b[bufnr].model_data

**0   if not line_to_model_id or not model_data then
**0     if config.get("debug") then
**0       vim.notify(string.format("Buffer data missing for bufnr %d (line_to_model_id: %s, model_data: %s)",
**0         bufnr, tostring(line_to_model_id), tostring(model_data)), vim.log.levels.DEBUG)
        end
**0     return nil, nil -- Return nil for both model_id and model_info
      end

**0   local model_id = line_to_model_id[current_line]
**0   if model_id and model_data[model_id] then
        -- Return model_id and the corresponding data table
**0     return model_id, model_data[model_id]
      end

      -- Add debug log if no model info is found for the line
**0   if config.get("debug") then
**0     local line_content = api.nvim_buf_get_lines(bufnr, current_line - 1, current_line, false)[1]
**0     vim.notify(string.format("No model info found for line %d (content: '%s', mapped_id: %s) in bufnr %d",
**0       current_line, line_content or "nil", tostring(model_id), bufnr), vim.log.levels.DEBUG)
      end

**0   return nil, nil -- Return nil for both model_id and model_info
    end

    -- Main function to open the model manager (now delegates to unified manager)
  3 function M.manage_models()
**0   require('llm.ui.unified_manager').open_specific_manager("Models")
    end

    -- Get custom OpenAI models
  3 function M.get_custom_openai_models()
**0   if vim.tbl_isempty(custom_openai.custom_openai_models) then
**0     custom_openai.load_custom_openai_models()
      end
**0   return custom_openai.custom_openai_models
    end

    -- Force reload custom OpenAI models
  3 function M.reload_custom_openai_models()
      -- Clear the cache and reload
**0   custom_openai.custom_openai_models = {}
**0   custom_openai.load_custom_openai_models()
**0   return custom_openai.custom_openai_models
    end

    -- Debug function for custom models (delegates to custom_openai module)
  3 function M.debug_custom_openai_models()
**0   return custom_openai.debug_custom_openai_models()
    end

    -- Create sample YAML file (delegates to custom_openai module)
  3 function M.create_sample_yaml_file()
**0   return custom_openai.create_sample_yaml_file()
    end

    -- Add module name for require path in keymaps
  3 M.__name = 'llm.managers.models_manager'

  3 return M

==============================================================================
lua/llm/managers/plugins_manager.lua
==============================================================================
    -- llm/managers/plugins_manager.lua - Plugin management for llm-nvim
    -- License: Apache 2.0

  2 local M = {}

    -- Forward declarations
  2 local api = vim.api
  2 local llm_cli = require('llm.core.data.llm_cli')
  2 local cache = require('llm.core.data.cache')
  2 local plugins_view = require('llm.ui.views.plugins_view')
  2 local styles = require('llm.ui.styles')

    local function parse_plugins_html(html)
  2   local plugins = {}
  2   vim.notify("Parsing HTML content of length: " .. #html, vim.log.levels.INFO)
  2   local sections = html:gmatch('<section id="([%w-]+)">(.-)</section>')

  4   for id, content in sections do
  2     local h2 = content:match('<h2>(.-)</h2>')
  2     if h2 then
          -- vim.notify("Found section: " .. h2, vim.log.levels.INFO) -- Removed per-section log
  2       local list_items = content:gmatch('<li>(.-)</li>')
  5       for item in list_items do
            local url, name, description
  3         local link_match = item:match('<a.->(.-)</a>')
  3         if link_match then
  3           name = link_match:match('<strong>(.-)</strong>') or link_match
  3           url = item:match('href="(.-)"')
  3           description = item:gsub('<[^>]+>', ''):gsub(name, '', 1):match('^:%s*(.*)') or item:gsub('<[^>]+>', ''):gsub(name, '', 1):match(':%s*(.*)')
  3           table.insert(plugins, { name = name, url = url, description = description })
              -- vim.notify("Parsed plugin: " .. name, vim.log.levels.INFO) -- Removed per-plugin log
            end
          end
        end
      end
  2   vim.notify("Finished parsing, found " .. #plugins .. " plugins.", vim.log.levels.INFO)
  2   return plugins
    end

    -- Get available plugins from the plugin directory
  2 function M.get_available_plugins()
  4   vim.notify("Getting available plugins...", vim.log.levels.INFO)
  4   local cached_plugins = cache.get('available_plugins')
  4   if cached_plugins then
  1     vim.notify("Returning cached plugins.", vim.log.levels.INFO)
  1     return cached_plugins
      end

  3   vim.notify("Fetching plugins from URL...", vim.log.levels.INFO)
  3   local plugins_html = vim.fn.system('curl -s https://llm.datasette.io/en/stable/plugins/directory.html')
  3   if not plugins_html or plugins_html == "" then
  1     vim.notify("Failed to fetch HTML from URL.", vim.log.levels.ERROR)
  1     return {}
      end
  2   vim.notify("Fetched HTML content, length: " .. #plugins_html, vim.log.levels.INFO)

  2   local plugins = parse_plugins_html(plugins_html)
  2   vim.notify("Parsed " .. #plugins .. " plugins from HTML.", vim.log.levels.INFO)

  2   cache.set('available_plugins', plugins)
  2   return plugins
    end

    local function trim(s)
**0   return s:match("^%s*(.-)%s*$")
    end

    local function trim(s)
  4   return s:match("^%s*(.-)%s*$")
    end

    -- Get installed plugins from llm CLI
  2 function M.get_installed_plugins()
  5   vim.notify("Getting installed plugins...", vim.log.levels.INFO)
  5   local cached_plugins = cache.get('installed_plugins')
  5   if cached_plugins then
  1     vim.notify("Returning cached installed plugins.", vim.log.levels.INFO)
  1     return cached_plugins
      end

  4   vim.notify("Running 'llm plugins' command...", vim.log.levels.INFO)
  4   local plugins_output = llm_cli.run_llm_command('plugins')
  4   if not plugins_output then
**0     vim.notify("'llm plugins' command returned no output.", vim.log.levels.WARN)
**0     return {}
      end
  4   plugins_output = trim(plugins_output)
      -- Remove any non-printable characters that might interfere with JSON parsing
  4   plugins_output = plugins_output:gsub("[^%w%p%s]", "")

  4   local plugins = {}
  4   local ok, decoded_plugins = pcall(vim.fn.json_decode, plugins_output)

  4   if ok and type(decoded_plugins) == 'table' then
        -- Successfully decoded as JSON
  7     for _, plugin_data in ipairs(decoded_plugins) do
  3       if plugin_data and plugin_data.name then
  3         table.insert(plugins, { name = plugin_data.name })
  3         vim.notify("Parsed installed plugin (JSON): '" .. plugin_data.name .. "'", vim.log.levels.INFO)
          end
        end
      else
**0     vim.notify("Failed to decode JSON from 'llm plugins' command: " .. tostring(decoded_plugins), vim.log.levels.ERROR)
**0     return {}
      end
  4   vim.notify("Finished parsing installed plugins, found " .. #plugins .. ".", vim.log.levels.INFO)
  4   cache.set('installed_plugins', plugins)
  4   return plugins
    end

    -- Check if a plugin is installed
  2 function M.is_plugin_installed(plugin_name)
  2   local installed_plugins = M.get_installed_plugins()
  3   for _, plugin in ipairs(installed_plugins) do
  2     if plugin.name == plugin_name then
  1       return true
        end
      end
  1   return false
    end

    -- Install a plugin using llm CLI
  2 function M.install_plugin(plugin_name)
  1   local result = llm_cli.run_llm_command('install ' .. plugin_name)
  1   cache.invalidate('installed_plugins')
  1   cache.invalidate('available_plugins')
  1   return result ~= nil
    end

    -- Uninstall a plugin using llm CLI
  2 function M.uninstall_plugin(plugin_name)
  1   local result = llm_cli.run_llm_command('uninstall ' .. plugin_name .. ' -y')
  1   cache.invalidate('installed_plugins')
  1   cache.invalidate('available_plugins')
  1   return result ~= nil
    end

    -- Populate the buffer with plugin management content
  2 function M.populate_plugins_buffer(bufnr)
**0   vim.notify("Populating plugins buffer...", vim.log.levels.INFO)
**0   local available_plugins = M.get_available_plugins()
**0   vim.notify("Got " .. #available_plugins .. " available plugins.", vim.log.levels.INFO)

**0   if not available_plugins or #available_plugins == 0 then
**0     vim.notify("No available plugins found. Displaying error message.", vim.log.levels.WARN)
**0     api.nvim_buf_set_lines(bufnr, 0, -1, false, {
          "# Plugin Management - Error",
          "",
          "No plugins found. Make sure llm is properly configured and plugin cache is up-to-date.",
          "",
          "Press [q]uit or use navigation keys ([M]odels, [K]eys, etc.)"
        })
**0     return {}, {} -- Return empty lookup tables
      end

**0   local installed_plugins = M.get_installed_plugins()
**0   vim.notify("DEBUG: Raw installed_plugins: " .. vim.inspect(installed_plugins), vim.log.levels.INFO)
**0   local installed_set = {}
**0   vim.notify("--- INSTALLED PLUGINS (" .. #installed_plugins .. ") ---", vim.log.levels.INFO)
**0   for _, plugin in ipairs(installed_plugins) do
**0     installed_set[plugin.name] = true
        -- vim.notify("Installed: '" .. plugin.name .. "' (added to set)", vim.log.levels.INFO) -- Removed per-plugin log
      end

**0   local available_plugin_names = {}
**0   for _, plugin in ipairs(available_plugins) do
**0     table.insert(available_plugin_names, plugin.name)
      end
**0   vim.notify("--- AVAILABLE PLUGINS (" .. #available_plugins .. ") ---\n" .. table.concat(available_plugin_names, ", "),
**0     vim.log.levels.INFO)

**0   local lines = {
        "# Plugin Management",
        "",
        "Navigate: [M]odels [K]eys [F]ragments [T]emplates [S]chemas",
        "Actions: [i]nstall [x]uninstall [r]efresh [q]uit",
        "──────────────────────────────────────────────────────────────",
        ""
      }

**0   local plugin_data = {}
**0   local line_to_plugin = {}
**0   local current_line = #lines + 1
      -- Add content to buffer
**0   for _, plugin in ipairs(available_plugins) do
**0     local desc = plugin.description or ""
**0     if #desc > 50 then desc = desc:sub(1, 47) .. "..." end
**0     local is_installed = installed_set[plugin.name]
**0     local status_char = is_installed and "✓" or " "
**0     local status_text = is_installed and "Installed" or "Not Installed"
**0     local line = string.format("[%s] %-30s - %s", status_char, plugin.name, status_text)
**0     table.insert(lines, line)
**0     plugin_data[plugin.name] = { line = current_line, installed = is_installed or false }
**0     line_to_plugin[current_line] = plugin.name
**0     current_line = current_line + 1
      end
**0   vim.notify("Prepared " .. #lines .. " lines for the buffer.", vim.log.levels.INFO)
**0   api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)

      -- Apply syntax highlighting and line-specific highlights
**0   styles.setup_highlights()
**0   styles.setup_buffer_syntax(bufnr) -- Use styles module

      -- Apply line-specific highlights for installed status
**0   local ns_id = api.nvim_create_namespace('LLMPluginsManagerHighlights')
**0   api.nvim_buf_clear_namespace(bufnr, ns_id, 0, -1)
**0   for i, plugin in ipairs(available_plugins) do
**0     local highlight_group = installed_set[plugin.name] and "LLMPluginInstalled" or "LLMPluginNotInstalled"
**0     local header_lines_count = 6                -- Number of fixed header lines
**0     local line_idx = header_lines_count + i - 1 -- Calculate the correct 0-based line index
**0     api.nvim_buf_add_highlight(bufnr, ns_id, highlight_group, line_idx, 0, -1)
      end

      -- Store lookup tables in buffer variables
**0   vim.b[bufnr].line_to_plugin = line_to_plugin
**0   vim.b[bufnr].plugin_data = plugin_data

**0   vim.notify("Finished populating plugins buffer.", vim.log.levels.INFO)
**0   return line_to_plugin, plugin_data -- Return for direct use if needed
    end

    -- Setup keymaps for the plugin management buffer
  2 function M.setup_plugins_keymaps(bufnr, manager_module)
**0   manager_module = manager_module or M -- Allow passing self

      local function set_keymap(mode, lhs, rhs)
**0     api.nvim_buf_set_keymap(bufnr, mode, lhs, rhs, { noremap = true, silent = true })
      end

      -- Install plugin under cursor
**0   set_keymap('n', 'i',
**0     string.format([[<Cmd>lua require('%s').install_plugin_under_cursor(%d)<CR>]],
**0       manager_module.__name or 'llm.managers.plugins_manager', bufnr))

      -- Uninstall plugin under cursor
**0   set_keymap('n', 'x',
**0     string.format([[<Cmd>lua require('%s').uninstall_plugin_under_cursor(%d)<CR>]],
**0       manager_module.__name or 'llm.managers.plugins_manager', bufnr))

      -- Refresh plugin list
**0   set_keymap('n', 'r',
**0     string.format([[<Cmd>lua require('%s').refresh_plugin_list(%d)<CR>]],
**0       manager_module.__name or 'llm.managers.plugins_manager', bufnr))
    end

    -- Action functions called by keymaps (now accept bufnr)
  2 function M.refresh_plugin_list(bufnr)
**0   M.refresh_available_plugins(function()
**0     require('llm.ui.unified_manager').switch_view("Plugins")
      end)
    end

  2 function M.install_plugin_under_cursor(bufnr)
**0   local plugin_name, plugin_info = M.get_plugin_info_under_cursor(bufnr)
**0   if not plugin_name then
**0     vim.notify("No plugin selected", vim.log.levels.WARN)
**0     return
      end
**0   if plugin_info.installed then
**0     vim.notify("Plugin " .. plugin_name .. " is already installed", vim.log.levels.INFO)
**0     return
      end

**0   vim.notify("Installing plugin: " .. plugin_name .. "... Please wait.", vim.log.levels.INFO)

      -- Run in schedule to avoid blocking UI
**0   vim.schedule(function()
**0     local success = M.install_plugin(plugin_name)
**0     if success then
**0       vim.notify("Successfully installed: " .. plugin_name, vim.log.levels.INFO)
**0       require('llm.ui.unified_manager').switch_view("Plugins")
        else
**0       vim.notify("Failed to install " .. plugin_name, vim.log.levels.ERROR)
        end
      end)
    end

  2 function M.uninstall_plugin_under_cursor(bufnr)
**0   local plugin_name, plugin_info = M.get_plugin_info_under_cursor(bufnr)
**0   if not plugin_name then
**0     vim.notify("No plugin selected", vim.log.levels.WARN)
**0     return
      end
**0   if not plugin_info.installed then
**0     vim.notify("Plugin " .. plugin_name .. " is not installed", vim.log.levels.INFO)
**0     return
      end

**0   plugins_view.confirm_uninstall(plugin_name, function(confirmed)
**0     if not confirmed then return end
**0     vim.notify("Uninstalling plugin: " .. plugin_name .. "... Please wait.", vim.log.levels.INFO)

        -- Run in schedule to avoid blocking UI
**0     vim.schedule(function()
**0       local success = M.uninstall_plugin(plugin_name)
**0       if success then
**0         vim.notify("Successfully uninstalled: " .. plugin_name, vim.log.levels.INFO)
**0         require('llm.ui.unified_manager').switch_view("Plugins")
          else
**0         vim.notify("Failed to uninstall " .. plugin_name, vim.log.levels.ERROR)
          end
        end)
      end)
    end

  2 function M.refresh_available_plugins(callback)
**0   vim.notify("Refreshing available plugins...", vim.log.levels.INFO)
**0   cache.invalidate('available_plugins')
**0   cache.invalidate('installed_plugins')
      -- Fetch in the background
**0   vim.defer_fn(function()
**0     local plugins = M.get_available_plugins()
**0     vim.notify("Finished refreshing plugins: " .. #plugins .. " found.", vim.log.levels.INFO)
**0     if callback then
**0       callback()
        end
**0   end, 0)
    end

    -- Helper to get plugin info from buffer variables
  2 function M.get_plugin_info_under_cursor(bufnr)
**0   local current_line = api.nvim_win_get_cursor(0)[1]
**0   local line_to_plugin = vim.b[bufnr].line_to_plugin
**0   local plugin_data = vim.b[bufnr].plugin_data
**0   if not line_to_plugin or not plugin_data then
**0     vim.notify("Buffer data missing", vim.log.levels.ERROR)
**0     return nil, nil
      end
**0   local plugin_name = line_to_plugin[current_line]
**0   if plugin_name and plugin_data[plugin_name] then
**0     return plugin_name, plugin_data[plugin_name]
      end
**0   return nil, nil
    end

    -- Main function to open the plugin manager (now delegates to unified manager)
  2 function M.manage_plugins()
**0   require('llm.ui.unified_manager').open_specific_manager("Plugins")
    end

    -- Add module name for require path in keymaps
  2 M.__name = 'llm.managers.plugins_manager'

  2 return M

==============================================================================
lua/llm/managers/schemas_manager.lua
==============================================================================
    -- llm/managers/schemas_manager.lua - Schema management for llm-nvim
    -- License: Apache 2.0

 15 local M = {}

    -- Forward declarations
 15 local api = vim.api
 15 local llm_cli = require('llm.core.data.llm_cli')
 15 local cache = require('llm.core.data.cache')
 15 local schemas_view = require('llm.ui.views.schemas_view')
 15 local styles = require('llm.ui.styles')

    -- Get schemas from llm CLI
 15 function M.get_schemas()
  2     local cached_schemas = cache.get('schemas')
  2     if cached_schemas then
  1         return cached_schemas
        end

  1     local schemas_json = llm_cli.run_llm_command('schemas list --json')
  1     local schemas = vim.fn.json_decode(schemas_json)
  1     cache.set('schemas', schemas)
  1     return schemas
    end

    -- Get a specific schema from llm CLI
 15 function M.get_schema(schema_id)
  1     local schema_json = llm_cli.run_llm_command('schemas get ' .. schema_id .. ' --json')
  1     return vim.fn.json_decode(schema_json)
    end

    -- Save a schema
 15 function M.save_schema(name, content, test_mode)
  2     local temp_file_path = vim.fn.tempname()
  2     if test_mode then
  1         return 'schemas save ' .. name .. ' ' .. temp_file_path
        end
  1     local file = io.open(temp_file_path, "w")
  1     if not file then
**0         return false
        end
  1     file:write(content)
  1     file:close()

  1     local result = llm_cli.run_llm_command('schemas save ' .. name .. ' ' .. temp_file_path)
  1     os.remove(temp_file_path)
  1     cache.invalidate('schemas')
  1     return result ~= nil
    end

    -- Run a schema
 15 function M.run_schema(schema_id, input, is_multi, bufnr, test_mode)
  3     local temp_file_path = vim.fn.tempname()
  3     if test_mode then
  2         local multi_flag = is_multi and " --multi" or ""
  2         return 'schema ' .. schema_id .. ' ' .. temp_file_path .. multi_flag
        end
  1     local file = io.open(temp_file_path, "w")
  1     if not file then
**0         return nil
        end
  1     file:write(input)
  1     file:close()

  1     local multi_flag = is_multi and " --multi" or ""
  1     local command_str = 'schema ' .. schema_id .. ' ' .. temp_file_path .. multi_flag

  1     local target_bufnr = bufnr
  1     if not target_bufnr then
**0         vim.cmd('vnew')
**0         target_bufnr = vim.api.nvim_get_current_buf()
**0         local buffer_name = "LLM Schema Result - " .. os.time()
**0         vim.api.nvim_buf_set_name(target_bufnr, buffer_name)
**0         vim.api.nvim_buf_set_option(target_bufnr, 'filetype', 'json')
**0         vim.api.nvim_buf_set_lines(target_bufnr, 0, -1, false, { "Waiting for response..." })
        end

  1     local cmd_parts = { llm_cli.get_llm_executable_path(), command_str }

  2     local job_id = require('llm.api').run_llm_command_streamed(cmd_parts, target_bufnr, {
            on_exit = function()
**0             vim.defer_fn(function() os.remove(temp_file_path) end, 0)
            end,
        })
  1     return job_id
    end

    -- Select and run a schema
 15 function M.select_schema()
**0   local schemas = M.get_schemas()
**0   schemas_view.select_schema(schemas, function(choice)
**0     if not choice then return end

**0     local has_selection = false
**0     local selection = ""
**0     local mode = api.nvim_get_mode().mode
**0     if mode == 'v' or mode == 'V' or mode == '' then
**0       selection = require('llm.core.utils.text').get_visual_selection()
**0       has_selection = selection ~= ""
        end

**0     if has_selection then
**0       schemas_view.get_schema_type(function(schema_type)
**0         if not schema_type then return end
**0         local is_multi = schema_type == "Multi schema (array of items)"
**0         M.run_schema(choice.id, selection, is_multi)
          end)
        else
**0       M.run_schema_with_input_source(choice.id)
        end
      end)
    end

    -- Run a schema with input from various sources
 15 function M.run_schema_with_input_source(schema_id)
**0   if not schema_id or schema_id == "" then
**0     vim.notify("Schema ID cannot be empty", vim.log.levels.ERROR)
**0     return
      end

**0   schemas_view.get_input_source(function(choice)
**0     if not choice then return end

**0     schemas_view.get_schema_type(function(schema_type)
**0       if not schema_type then return end
**0       local is_multi = schema_type == "Multi schema (array of items)"

**0       if choice == "Current buffer" then
**0         local lines = api.nvim_buf_get_lines(0, 0, -1, false)
**0         local content = table.concat(lines, "\n")
**0         vim.notify("Running schema on buffer content...", vim.log.levels.INFO)
**0         M.run_schema(schema_id, content, is_multi, bufnr)
**0       elseif choice == "URL (will use curl)" then
**0         schemas_view.get_url(function(url)
**0           if not url or url == "" then
**0             vim.notify("URL cannot be empty", vim.log.levels.WARN)
**0             return
              end
**0           vim.notify("Running schema on URL content...", vim.log.levels.INFO)
**0           M.run_schema(schema_id, url, is_multi, bufnr)
            end)
**0       elseif choice == "Enter text manually" then
**0         M.handle_manual_text_input(schema_id, is_multi)
          end
        end)
      end)
    end

 15 function M.handle_manual_text_input(schema_id, is_multi)
**0   local temp_dir = vim.fn.stdpath('cache') .. "/llm_nvim_temp"
**0   os.execute("mkdir -p " .. temp_dir)
**0   local temp_file_path = string.format("%s/schema_input_%s_%s.txt", temp_dir, schema_id:sub(1, 8), os.time())

**0   local buf = api.nvim_create_buf(false, true)
**0   api.nvim_buf_set_option(buf, "buftype", "acwrite")
**0   api.nvim_buf_set_option(buf, "bufhidden", "wipe")
**0   api.nvim_buf_set_option(buf, "swapfile", false)
**0   api.nvim_buf_set_name(buf, temp_file_path)

**0   api.nvim_buf_set_lines(buf, 0, -1, false, {
**0     "# Enter text to process with schema " .. schema_id,
        "# Press :w to save and submit, or :q! to cancel",
        "",
        ""
      })

**0   api.nvim_command("split")
**0   api.nvim_win_set_buf(0, buf)
**0   api.nvim_win_set_cursor(0, { 4, 0 })

**0   api.nvim_buf_set_var(buf, "llm_schema_id", schema_id)
**0   api.nvim_buf_set_var(buf, "llm_schema_is_multi", is_multi)
**0   api.nvim_buf_set_var(buf, "llm_temp_file_path", temp_file_path)

**0   local group = api.nvim_create_augroup("LLMSchemaInput", { clear = true })
**0   api.nvim_create_autocmd("BufWriteCmd", {
        group = group,
        buffer = buf,
        callback = function(args)
**0       if api.nvim_buf_is_valid(args.buf) then
**0         api.nvim_buf_set_option(args.buf, "modified", false)
**0         require('llm.managers.schemas_manager').submit_schema_input_from_buffer(args.buf)
**0         return true
          end
        end,
      })

**0   api.nvim_buf_create_user_command(buf, "LlmSchemaCancel", function()
**0     local temp_file = api.nvim_buf_get_var(buf, "llm_temp_file_path")
**0     api.nvim_command(buf .. "bdelete!")
**0     if temp_file and vim.fn.filereadable(temp_file) == 1 then
**0       os.remove(temp_file)
        end
**0     vim.notify("Schema input cancelled.", vim.log.levels.INFO)
**0   end, {})

      local function set_keymap(mode, lhs, rhs, opts)
**0     opts = opts or { noremap = true, silent = true }
**0     api.nvim_buf_set_keymap(buf, mode, lhs, rhs, opts)
      end

**0   set_keymap("n", "<Esc>", ":LlmSchemaCancel<CR>")
**0   vim.notify("Enter text in this buffer. Save (:w) to submit or quit (:q!) to cancel.", vim.log.levels.INFO)
**0   api.nvim_command('startinsert')
    end

 15 function M.submit_schema_input_from_buffer(buf)
**0   if not api.nvim_buf_is_valid(buf) then
**0     vim.notify("Invalid buffer for schema input", vim.log.levels.ERROR)
**0     return
      end

**0   local schema_id = api.nvim_buf_get_var(buf, "llm_schema_id")
**0   local is_multi = api.nvim_buf_get_var(buf, "llm_schema_is_multi")
**0   local lines = api.nvim_buf_get_lines(buf, 3, -1, false)
**0   local content = table.concat(lines, "\n")

**0   api.nvim_command(buf .. "bdelete!")
**0   vim.notify("Running schema on input text...", vim.log.levels.INFO)

**0   local result = M.run_schema(schema_id, content, is_multi)
**0   if result then
**0     require('llm.core.utils.ui').create_buffer_with_content(result, "Schema Result: " .. schema_id, "json")
      else
**0     vim.notify("Failed to run schema on input text", vim.log.levels.ERROR)
      end
    end

 15 function M.create_schema()
**0   schemas_view.get_schema_name(function(name)
**0     if not name or name == "" then
**0       vim.notify("Schema name cannot be empty", vim.log.levels.WARN)
**0       return
        end
**0     if name:match("[/\\]") then
**0       vim.notify("Schema name cannot contain path separators (/ or \\)", vim.log.levels.ERROR)
**0       return
        end

**0     schemas_view.get_schema_format(function(format_choice)
**0       if not format_choice then return end
**0       M.handle_schema_creation(name, format_choice)
        end)
      end)
    end

 15 function M.handle_schema_creation(name, format_choice)
**0   local temp_dir = vim.fn.stdpath('cache') .. "/llm_nvim_temp"
**0   os.execute("mkdir -p " .. temp_dir)
**0   local file_ext = (format_choice == "JSON Schema") and ".json" or ".dsl"
**0   local safe_name = name:gsub("[^%w_-]", "_")
**0   local temp_file_path = string.format("%s/schema_edit_%s_%s%s", temp_dir, safe_name, os.time(), file_ext)

**0   local boilerplate = ""
**0   if format_choice == "JSON Schema" then
**0     boilerplate = "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"property_name\": {\n      \"type\": \"string\",\n      \"description\": \"Description of the property\"\n    }\n  },\n  \"required\": [\"property_name\"]\n}"
      else
**0     boilerplate = "# Define schema properties using DSL syntax\n# Example:\n# name: the person's name\n# age int: their age in years\n# bio: a short biography\n\n"
      end

**0   local file = io.open(temp_file_path, "w")
**0   if not file then
**0     vim.notify("Failed to create temporary schema file: " .. temp_file_path, vim.log.levels.ERROR)
**0     return
      end
**0   file:write(boilerplate)
**0   file:close()

**0   api.nvim_command("split " .. vim.fn.fnameescape(temp_file_path))
**0   local bufnr = api.nvim_get_current_buf()

**0   if format_choice == "JSON Schema" then
**0     api.nvim_buf_set_option(bufnr, 'filetype', 'json')
      else
**0     api.nvim_buf_set_option(bufnr, 'filetype', 'markdown')
      end

**0   api.nvim_buf_set_var(bufnr, "llm_schema_name", name)
**0   api.nvim_buf_set_var(bufnr, "llm_schema_format", format_choice)
**0   api.nvim_buf_set_var(bufnr, "llm_temp_schema_file_path", temp_file_path)

**0   local group = api.nvim_create_augroup("LLMSchemaSave", { clear = true })
**0   api.nvim_create_autocmd("BufWritePost", {
        group = group,
        buffer = bufnr,
        callback = function(args)
**0       if api.nvim_buf_is_valid(args.buf) then
**0         require('llm.managers.schemas_manager').save_schema_from_temp_file(args.buf)
          end
        end,
      })

**0   api.nvim_buf_create_user_command(bufnr, "LlmCancel", function()
**0     local temp_file = api.nvim_buf_get_var(bufnr, "llm_temp_schema_file_path")
**0     api.nvim_command(bufnr .. "bdelete!")
**0     if temp_file and vim.fn.filereadable(temp_file) == 1 then
**0       os.remove(temp_file)
        end
**0     vim.notify("Schema creation cancelled.", vim.log.levels.INFO)
**0   end, {})

**0   vim.notify("Edit the schema in this buffer. Save (:w) to validate and finalize. Use :LlmCancel to abort.", vim.log.levels.INFO)
    end

 15 function M.save_schema_from_temp_file(bufnr)
**0   if not api.nvim_buf_is_valid(bufnr) then
**0     return
      end

**0   local name = api.nvim_buf_get_var(bufnr, "llm_schema_name")
**0   local format_choice = api.nvim_buf_get_var(bufnr, "llm_schema_format")
**0   local temp_file_path = api.nvim_buf_get_var(bufnr, "llm_temp_schema_file_path")
**0   local content = table.concat(api.nvim_buf_get_lines(bufnr, 0, -1, false), "\n")
**0   content = content:gsub("^%s+", ""):gsub("%s+$", "")

**0   local validated_content, is_valid, error_message = M.validate_schema(content, format_choice)

**0   if not is_valid then
**0     vim.notify("Schema validation failed: " .. error_message, vim.log.levels.ERROR)
**0     vim.notify("Schema not saved. Please fix the content and save again (:w), or use :LlmCancel to abort.", vim.log.levels.WARN)
**0     return
      end

**0   vim.notify("Schema validated. Saving schema '" .. name .. "'...", vim.log.levels.INFO)
**0   local success = M.save_schema(name, validated_content)
**0   if success then
**0     vim.notify("Schema '" .. name .. "' saved successfully", vim.log.levels.INFO)
**0     vim.defer_fn(function()
**0       M.manage_schemas()
**0     end, 1500)
**0     api.nvim_command(bufnr .. "bdelete!")
**0     if temp_file_path then os.remove(temp_file_path) end
      else
**0     vim.notify("Failed to save schema '" .. name .. "'", vim.log.levels.ERROR)
      end
    end

 15 function M.validate_schema(content, format)
        -- Validation is now handled by the llm-cli
**0     return content, true, nil
    end

 15 function M.populate_schemas_buffer(bufnr)
**0   if _G.llm_schemas_named_only == nil then
**0     _G.llm_schemas_named_only = true
      end
**0   local show_named_only = _G.llm_schemas_named_only

**0   local all_schemas = M.get_schemas()
**0   local named_schemas, unnamed_schemas = M.categorize_schemas(all_schemas)
**0   local schemas_to_show = show_named_only and named_schemas or vim.list_extend(vim.deepcopy(named_schemas), unnamed_schemas)

**0   local lines = M.build_buffer_lines(schemas_to_show, show_named_only)
**0   local schema_data, line_to_schema = M.build_schema_data(schemas_to_show, #lines + 1)

**0   api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)
**0   styles.setup_highlights()
**0   styles.setup_buffer_syntax(bufnr)
**0   vim.b[bufnr].line_to_schema = line_to_schema
**0   vim.b[bufnr].schema_data = schema_data
**0   vim.b[bufnr].schemas = schemas_to_show
    end

 15 function M.categorize_schemas(all_schemas)
  1   local named_schemas = {}
  1   local unnamed_schemas = {}

  5   for _, schema in ipairs(all_schemas) do
  4     if schema.name then
  3       table.insert(named_schemas, schema)
        else
  1       table.insert(unnamed_schemas, schema)
        end
      end

  4   table.sort(named_schemas, function(a, b) return a.name < b.name end)
  1   table.sort(unnamed_schemas, function(a, b) return a.id < b.id end)
  1   return named_schemas, unnamed_schemas
    end

 15 function M.build_buffer_lines(schemas, show_named_only)
  1   local lines = {
  1     "# Schema Management",
  1     "",
  1     "Navigate: [M]odels [P]lugins [K]eys [F]ragments [T]emplates",
  1     "Actions: [c]reate [r]un [v]iew [e]dit [a]lias [d]elete alias [t]oggle view [q]uit",
  1     "──────────────────────────────────────────────────────────────",
  1     "",
  1     show_named_only and "Showing: Only named schemas" or "Showing: All schemas",
        ""
  1   }
  1   if #schemas == 0 then
**0     table.insert(lines, "No schemas found. Press 'c' to create one.")
      else
  1     table.insert(lines, "Schemas:")
  1     table.insert(lines, "----------")
  3     for i, schema in ipairs(schemas) do
  2       local description = schema.description:gsub("\n", " ")
  2       local schema_details = M.get_schema(schema.id)
  2       local is_valid = schema_details and schema_details.content and pcall(vim.fn.json_decode, schema_details.content)
  2       table.insert(lines, string.format("Schema %d: %s", i, schema.id))
  2       if schema.name then
  1         table.insert(lines, string.format("  Name: %s", schema.name))
          end
  2       table.insert(lines, string.format("  Status: %s", is_valid and "Valid" or "Invalid"))
  2       table.insert(lines, string.format("  Description: %s", description))
  2       table.insert(lines, "")
        end
      end
  1   return lines
    end

 15 function M.build_schema_data(schemas, start_line)
  1   local schema_data = {}
  1   local line_to_schema = {}
  1   local current_line = start_line
  2   for i, schema in ipairs(schemas) do
  1     local entry_lines = 1
  1     if schema.name then entry_lines = entry_lines + 1 end
  1     entry_lines = entry_lines + 3

  1     schema_data[schema.id] = {
  1       index = i,
  1       name = schema.name,
  1       description = schema.description,
  1       is_valid = M.get_schema(schema.id) and true or false,
  1       start_line = current_line,
  1     }
  6     for j = 0, entry_lines - 1 do
  5       line_to_schema[current_line + j] = schema.id
        end
  1     current_line = current_line + entry_lines
      end
  1   return schema_data, line_to_schema
    end


 15 function M.setup_schemas_keymaps(bufnr, manager_module)
**0   manager_module = manager_module or M
      local function set_keymap(mode, lhs, rhs)
**0     api.nvim_buf_set_keymap(bufnr, mode, lhs, rhs, { noremap = true, silent = true })
      end
**0   set_keymap('n', 'c', string.format([[<Cmd>lua require('%s').create_schema_from_manager(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'r', string.format([[<Cmd>lua require('%s').run_schema_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'v', string.format([[<Cmd>lua require('%s').view_schema_details_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'e', string.format([[<Cmd>lua require('%s').edit_schema_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'a', string.format([[<Cmd>lua require('%s').set_alias_for_schema_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 'd', string.format([[<Cmd>lua require('%s').delete_alias_for_schema_under_cursor(%d)<CR>]], manager_module.__name, bufnr))
**0   set_keymap('n', 't', string.format([[<Cmd>lua require('%s').toggle_schemas_view(%d)<CR>]], manager_module.__name, bufnr))
    end

 15 function M.run_schema_under_cursor(bufnr)
**0   local schema_id, _ = M.get_schema_info_under_cursor(bufnr)
**0   if not schema_id then
**0     vim.notify("No schema found under cursor", vim.log.levels.ERROR)
**0     return
      end
**0   require('llm.ui.unified_manager').close()
**0   vim.schedule(function()
**0     M.run_schema_with_input_source(schema_id)
      end)
    end

 15 function M.view_schema_details_under_cursor(bufnr)
**0   local schema_id, _ = M.get_schema_info_under_cursor(bufnr)
**0   if not schema_id then
**0     vim.notify("No schema found under cursor", vim.log.levels.ERROR)
**0     return
      end
**0   local schema = M.get_schema(schema_id)
**0   if not schema then
**0     vim.notify("Failed to get schema details for '" .. schema_id .. "'", vim.log.levels.ERROR)
**0     return
      end
**0   require('llm.ui.unified_manager').close()
**0   vim.schedule(function()
**0     schemas_view.show_details(schema_id, schema, M)
      end)
    end

 15 function M.set_alias_for_schema_under_cursor(bufnr)
**0   local schema_id, schema_info = M.get_schema_info_under_cursor(bufnr)
**0   if not schema_id then
**0     vim.notify("No schema found under cursor", vim.log.levels.ERROR)
**0     return
      end
**0   schemas_view.get_alias(schema_info.name, function(new_alias)
**0     if not new_alias or new_alias == "" then
**0       vim.notify("Alias cannot be empty", vim.log.levels.WARN)
**0       return
        end
**0     if new_alias:match("[/\\]") then
**0       vim.notify("Alias cannot contain path separators (/ or \\)", vim.log.levels.ERROR)
**0       return
        end
**0     if llm_cli.run_llm_command('schemas alias set ' .. schema_id .. ' ' .. new_alias) then
**0       vim.notify("Schema alias set to '" .. new_alias .. "'", vim.log.levels.INFO)
**0       cache.invalidate('schemas')
**0       require('llm.ui.unified_manager').switch_view("Schemas")
        else
**0       vim.notify("Failed to set schema alias", vim.log.levels.ERROR)
        end
      end)
    end

 15 function M.create_schema_from_manager(bufnr)
**0   require('llm.ui.unified_manager').close()
**0   vim.schedule(function()
**0     M.create_schema()
      end)
    end

 15 function M.run_schema_from_details(schema_id)
**0   api.nvim_win_close(0, true)
**0   vim.schedule(function()
**0     M.run_schema_with_input_source(schema_id)
      end)
    end

 15 function M.set_alias_from_details(schema_id)
**0   local schema = M.get_schema(schema_id)
**0   schemas_view.get_alias(schema and schema.name, function(new_alias)
**0     if not new_alias or new_alias == "" then
**0       vim.notify("Alias cannot be empty", vim.log.levels.WARN)
**0       return
        end
**0     if new_alias:match("[/\\]") then
**0       vim.notify("Alias cannot contain path separators (/ or \\)", vim.log.levels.ERROR)
**0       return
        end
**0     if llm_cli.run_llm_command('schemas alias set ' .. schema_id .. ' ' .. new_alias) then
**0       vim.notify("Schema alias set to '" .. new_alias .. "'", vim.log.levels.INFO)
**0       cache.invalidate('schemas')
**0       api.nvim_win_close(0, true)
**0       vim.schedule(function()
**0         require('llm.ui.unified_manager').open_specific_manager("Schemas")
          end)
        else
**0       vim.notify("Failed to set schema alias", vim.log.levels.ERROR)
        end
      end)
    end

 15 function M.delete_alias_for_schema_under_cursor(bufnr)
**0   local schema_id, schema_info = M.get_schema_info_under_cursor(bufnr)
**0   if not schema_id or not schema_info.name then
**0     vim.notify("No schema with an alias found under cursor", vim.log.levels.ERROR)
**0     return
      end
**0   schemas_view.confirm_delete_alias(schema_info.name, function(confirmed)
**0     if not confirmed then return end
**0     if llm_cli.run_llm_command('schemas alias remove ' .. schema_info.name) then
**0       vim.notify("Schema alias '" .. schema_info.name .. "' deleted", vim.log.levels.INFO)
**0       cache.invalidate('schemas')
**0       require('llm.ui.unified_manager').switch_view("Schemas")
        else
**0       vim.notify("Failed to delete schema alias", vim.log.levels.ERROR)
        end
      end)
    end

 15 function M.edit_schema_under_cursor(bufnr)
**0   local schema_id, _ = M.get_schema_info_under_cursor(bufnr)
**0   if not schema_id then
**0     vim.notify("No schema found under cursor", vim.log.levels.ERROR)
**0     return
      end
**0   require('llm.ui.unified_manager').close()
**0   vim.schedule(function()
**0     M.edit_schema_from_details(schema_id)
      end)
    end

 15 function M.toggle_schemas_view(bufnr)
**0   _G.llm_schemas_named_only = not (_G.llm_schemas_named_only == true)
**0   require('llm.ui.unified_manager').close()
**0   vim.schedule(function()
**0     require('llm.ui.unified_manager').open_specific_manager("Schemas")
      end)
    end

 15 function M.delete_alias_from_details(schema_id)
**0   local schema = M.get_schema(schema_id)
**0   if not schema or not schema.name then
**0     vim.notify("This schema does not have an alias to delete", vim.log.levels.WARN)
**0     return
      end
**0   schemas_view.confirm_delete_alias(schema.name, function(confirmed)
**0     if not confirmed then return end
**0     if llm_cli.run_llm_command('schemas alias remove ' .. schema.name) then
**0       vim.notify("Schema alias '" .. schema.name .. "' deleted", vim.log.levels.INFO)
**0       cache.invalidate('schemas')
**0       api.nvim_win_close(0, true)
**0       vim.schedule(function()
**0         require('llm.ui.unified_manager').open_specific_manager("Schemas")
          end)
        else
**0       vim.notify("Failed to delete schema alias", vim.log.levels.ERROR)
        end
      end)
    end

 15 function M.get_schema_info_under_cursor(bufnr)
**0   local current_line = api.nvim_win_get_cursor(0)[1]
**0   local line_to_schema = vim.b[bufnr].line_to_schema
**0   local schema_data = vim.b[bufnr].schema_data
**0   if not line_to_schema or not schema_data then
**0     vim.notify("Buffer data missing", vim.log.levels.ERROR)
**0     return nil, nil
      end
**0   local schema_id = line_to_schema[current_line]
**0   if schema_id and schema_data[schema_id] then
**0     return schema_id, schema_data[schema_id]
      end
**0   return nil, nil
    end

 15 function M.manage_schemas(show_named_only)
**0   _G.llm_schemas_named_only = show_named_only or true
**0   require('llm.ui.unified_manager').open_specific_manager("Schemas")
    end

 15 M.__name = 'llm.managers.schemas_manager'

 15 return M

==============================================================================
lua/llm/managers/templates_manager.lua
==============================================================================
    -- llm/managers/templates_manager.lua - Template management for llm-nvim
    -- License: Apache 2.0

  2 local M = {}

    -- Forward declarations
  2 local api = require('llm.api')
  2 local v_api = vim.api
  2 local llm_cli = require('llm.core.data.llm_cli')
  2 local cache = require('llm.core.data.cache')
  2 local templates_view = require('llm.ui.views.templates_view')
  2 local styles = require('llm.ui.styles')
  2 local models_manager = require('llm.managers.models_manager')

    -- Get templates from llm CLI
  2 function M.get_templates()
  1     local cached_templates = cache.get('templates')
  1     if cached_templates then
**0         return cached_templates
        end

  1     local templates_json = llm_cli.run_llm_command('templates list --json')
  1     local templates = vim.fn.json_decode(templates_json)
  1     cache.set('templates', templates)
  1     return templates
    end

    -- Get a specific template from llm CLI
  2 function M.get_template_details(template_name)
  1     local template_json = llm_cli.run_llm_command('templates show ' .. template_name)
  1     return vim.fn.json_decode(template_json)
    end

    -- Create a template
    -- Save a template
  2 function M.save_template(name, prompt, system, model, options, fragments, system_fragments, defaults, extract, schema)
  1     local cmd = 'templates save ' .. name
  1     if prompt then
  1         cmd = cmd .. " --prompt '" .. prompt .. "'"
        end
  1     if system then
  1         cmd = cmd .. " --system '" .. system .. "'"
        end
  1     if model then
  1         cmd = cmd .. ' --model ' .. model
        end
  2     for k, v in pairs(options) do
  1         cmd = cmd .. " -o " .. k .. " '" .. tostring(v) .. "'"
        end
  2     for _, f in ipairs(fragments) do
  1         cmd = cmd .. ' -f ' .. f
        end
  2     for _, f in ipairs(system_fragments) do
  1         cmd = cmd .. ' -sf ' .. f
        end
  2     for k, v in pairs(defaults) do
  1         cmd = cmd .. " -d " .. k .. " '" .. v .. "'"
        end
  1     if extract then
  1         cmd = cmd .. ' --extract'
        end
  1     if schema then
  1         cmd = cmd .. ' --schema ' .. schema
        end

  1     local result = llm_cli.run_llm_command(cmd)
  1     cache.invalidate('templates')
  1     return result ~= nil
    end

    -- Delete a template
  2 function M.delete_template(template_name)
  1     local result = llm_cli.run_llm_command('templates delete ' .. template_name .. ' -y')
  1     cache.invalidate('templates')
  1     return result ~= nil
    end

    -- Run a template
  2 function M.run_template(template_name, input, params)
  2     local cmd = { llm_cli.get_llm_executable_path(), "-t", template_name }
  2     if input then
  2         table.insert(cmd, "'" .. input .. "'")
        end
  3     for k, v in pairs(params) do
  1         table.insert(cmd, "-p")
  1         table.insert(cmd, k)
  1         table.insert(cmd, "'" .. v .. "'")
        end
  2     return cmd
    end

    -- Select and run a template
  2 function M.select_template()
**0   local templates = M.get_templates()
**0   templates_view.select_template(templates, function(choice)
**0     if not choice then return end

        -- If we have a selection, use it directly
**0     local has_selection = false
**0     local selection = ""
**0     local mode = api.nvim_get_mode().mode
**0     if mode == 'v' or mode == 'V' or mode == '' then
          -- Get the visual selection
**0       selection = require('llm.core.utils.text').get_visual_selection()
**0       has_selection = selection ~= ""
        end

**0     if has_selection then
**0       M.run_template_with_selection(choice.name, selection)
        else
**0       M.run_template_with_params(choice.name)
        end
      end)
    end

  2 function M.run_template_with_selection(template_name, selection)
  1   local template = M.get_template_details(template_name)
  1   if not template then
**0     vim.notify("Failed to get template details", vim.log.levels.ERROR)
**0     return
      end

  1   local params = {}
  1   local param_names = M.extract_params(template)

  1   if #param_names > 0 then
**0     M.collect_params_and_run(template_name, selection, param_names, template.defaults, function(final_params)
**0       local cmd_parts = M.run_template(template_name, selection, final_params)
**0       local response_buf = v_api.nvim_create_buf(false, true)
**0       v_api.nvim_buf_set_option(response_buf, "buftype", "nofile")
**0       v_api.nvim_buf_set_option(response_buf, "bufhidden", "wipe")
**0       v_api.nvim_buf_set_option(response_buf, "swapfile", false)
**0       v_api.nvim_buf_set_name(response_buf, "Template Result: " .. template_name)
**0       require('llm.core.utils.ui').create_floating_window(response_buf, "Template Result: " .. template_name)
**0       api.run_llm_command_streamed(cmd_parts, response_buf)
        end)
      else
  1     local cmd_parts = M.run_template(template_name, selection, {})
  1     local response_buf = v_api.nvim_create_buf(false, true)
  1     v_api.nvim_buf_set_option(response_buf, "buftype", "nofile")
  1     v_api.nvim_buf_set_option(response_buf, "bufhidden", "wipe")
  1     v_api.nvim_buf_set_option(response_buf, "swapfile", false)
  1     v_api.nvim_buf_set_name(response_buf, "Template Result: " .. template_name)
  1     require('llm.core.utils.ui').create_floating_window(response_buf, "Template Result: " .. template_name)
  1     api.run_llm_command_streamed(cmd_parts, response_buf)
      end
    end

  2 function M.extract_params(template)
  1   local param_names = {}
      local function extract(text)
  2     if not text then return end
  1     for param in text:gmatch("%$([%w_]+)") do
**0       if param ~= "input" and not vim.tbl_contains(param_names, param) then
**0         table.insert(param_names, param)
          end
        end
      end
  1   extract(template.prompt)
  1   extract(template.system)
  1   return param_names
    end

  2 function M.collect_params_and_run(template_name, selection, param_names, defaults, callback)
**0   local params = {}
      local function collect_next_param(index)
**0     if index > #param_names then
**0       callback(params)
**0       return
        end

**0     local param = param_names[index]
**0     local default = defaults and defaults[param] or ""

**0     templates_view.get_user_input("Enter value for parameter '" .. param .. "':", default, function(value)
**0       if value then
**0         params[param] = value
**0         collect_next_param(index + 1)
          end
        end)
      end
**0   collect_next_param(1)
    end

    -- Run a template with parameters
  2 function M.run_template_with_params(template_name)
**0   if not template_name or template_name == "" then
**0     vim.notify("Template name cannot be empty", vim.log.levels.ERROR)
**0     return
      end

**0   local template = M.get_template_details(template_name)
**0   if not template then
**0     vim.notify("Failed to get template details", vim.log.levels.ERROR)
**0     return
      end

**0   local param_names = M.extract_params(template)

**0   if #param_names > 0 then
**0     M.collect_params_and_run(template_name, nil, param_names, template.defaults, function(final_params)
**0       M.run_template_with_input(template_name, final_params)
        end)
      else
**0     M.run_template_with_input(template_name, {})
      end
    end

    -- Run a template with input (selection, buffer, or URL)
  2 function M.run_template_with_input(template_name, params)
**0   if not template_name or template_name == "" then
**0     vim.notify("Template name cannot be empty", vim.log.levels.ERROR)
**0     return
      end

**0   templates_view.get_input_source(function(choice)
**0     if not choice then return end

**0     if choice == "Current selection" then
**0       local selection = require('llm.core.utils.text').get_visual_selection()
**0       if selection == "" then
**0         vim.notify("No text selected", vim.log.levels.ERROR)
**0         return
          end
**0       local cmd_parts = M.run_template(template_name, selection, params)
**0       local response_buf = v_api.nvim_create_buf(false, true)
**0       v_api.nvim_buf_set_option(response_buf, "buftype", "nofile")
**0       v_api.nvim_buf_set_option(response_buf, "bufhidden", "wipe")
**0       v_api.nvim_buf_set_option(response_buf, "swapfile", false)
**0       v_api.nvim_buf_set_name(response_buf, "Template Result: " .. template_name)
**0       require('llm.core.utils.ui').create_floating_window(response_buf, "Template Result: " .. template_name)
**0       api.run_llm_command_streamed(cmd_parts, response_buf)
**0     elseif choice == "Current buffer" then
**0       local lines = v_api.nvim_buf_get_lines(0, 0, -1, false)
**0       local content = table.concat(lines, "\n")
**0       local cmd_parts = M.run_template(template_name, content, params)
**0       local response_buf = v_api.nvim_create_buf(false, true)
**0       v_api.nvim_buf_set_option(response_buf, "buftype", "nofile")
**0       v_api.nvim_buf_set_option(response_buf, "bufhidden", "wipe")
**0       v_api.nvim_buf_set_option(response_buf, "swapfile", false)
**0       v_api.nvim_buf_set_name(response_buf, "Template Result: " .. template_name)
**0       require('llm.core.utils.ui').create_floating_window(response_buf, "Template Result: " .. template_name)
**0       api.run_llm_command_streamed(cmd_parts, response_buf)
**0     elseif choice == "URL (will use curl)" then
**0       templates_view.get_user_input("Enter URL:", nil, function(url)
**0         if not url or url == "" then
**0           vim.notify("URL cannot be empty", vim.log.levels.WARN)
**0           return
            end
**0         local result = M.run_template(template_name, url, params)
**0         if result then
**0           require('llm.core.utils.ui').create_buffer_with_content(result, "Template Result: " .. template_name, "markdown")
            end
          end)
        end
      end)
    end

    -- Create a template with guided flow
  2 function M.create_template_guided()
**0   templates_view.get_user_input("Enter template name:", nil, function(name)
**0     if not name or name == "" then
**0       vim.notify("Template name cannot be empty", vim.log.levels.WARN)
**0       return
        end
**0     if name:match("[/\\]") then
**0       vim.notify("Template name cannot contain path separators (/ or \\)", vim.log.levels.ERROR)
**0       return
        end

**0     local template = { name = name, defaults = {}, options = {}, fragments = {}, system_fragments = {} }
**0     M.continue_template_creation_type(template)
      end)
    end

  2 function M.continue_template_creation_type(template)
**0   templates_view.get_template_type(function(type_choice)
**0     if not type_choice then return end

**0     if type_choice == "Regular prompt" then
**0       templates_view.get_user_input("Enter prompt (use $input for user input):", "$input", function(prompt)
**0         if not prompt or prompt == "" then
**0           vim.notify("Prompt cannot be empty", vim.log.levels.WARN)
**0           return
            end
**0         template.prompt = prompt
**0         M.continue_template_creation_model(template)
          end)
**0     elseif type_choice == "System prompt only" then
**0       templates_view.get_user_input("Enter system prompt:", nil, function(system)
**0         if not system or system == "" then
**0           vim.notify("System prompt cannot be empty", vim.log.levels.WARN)
**0           return
            end
**0         template.system = system
**0         M.continue_template_creation_model(template)
          end)
        else -- Both
**0       templates_view.get_user_input("Enter system prompt:", nil, function(system)
**0         if not system or system == "" then
**0           vim.notify("System prompt cannot be empty", vim.log.levels.WARN)
**0           return
            end
**0         template.system = system
**0         templates_view.get_user_input("Enter regular prompt (use $input for user input):", "$input", function(prompt)
**0           if not prompt or prompt == "" then
**0             vim.notify("Prompt cannot be empty", vim.log.levels.WARN)
**0             return
              end
**0           template.prompt = prompt
**0           M.continue_template_creation_model(template)
            end)
          end)
        end
      end)
    end

  2 function M.continue_template_creation_model(template)
**0   templates_view.get_model_choice(function(model_choice)
**0     if not model_choice then return end
**0     if model_choice == "Select specific model" then
**0       local models = models_manager.get_available_models()
**0       templates_view.select_model(models, function(model)
**0         if model then
**0           template.model = models_manager.extract_model_name(model)
            end
**0         M.continue_template_creation_fragments(template)
          end)
        else
**0       M.continue_template_creation_fragments(template)
        end
      end)
    end

  2 function M.continue_template_creation_fragments(template)
**0   templates_view.get_fragment_choice(function(fragment_choice)
**0     if not fragment_choice then return end
**0     if fragment_choice == "Add fragments" then
**0       M.add_fragments_loop(template, "fragments", function()
**0         M.continue_template_creation_options(template)
          end)
**0     elseif fragment_choice == "Add system fragments" then
**0       M.add_fragments_loop(template, "system_fragments", function()
**0         M.continue_template_creation_options(template)
          end)
        else
**0       M.continue_template_creation_options(template)
        end
      end)
    end

  2 function M.add_fragments_loop(template, fragment_type, on_done)
**0   templates_view.get_add_fragment_choice(function(choice)
**0     if not choice or choice == "Done adding fragments" then
**0       on_done()
**0       return
        end

**0     if choice == "Select from file browser" then
**0       require('llm.managers.fragments_manager').select_file_as_fragment(function(fragment_path)
**0         if fragment_path then
**0           table.insert(template[fragment_type], fragment_path)
            end
**0         M.add_fragments_loop(template, fragment_type, on_done)
          end)
**0     elseif choice == "Enter fragment path/URL" then
**0       templates_view.get_user_input("Enter fragment path or URL:", nil, function(path)
**0         if path and path ~= "" then
**0           table.insert(template[fragment_type], path)
            else
**0           vim.notify("Fragment path/URL cannot be empty", vim.log.levels.WARN)
            end
**0         M.add_fragments_loop(template, fragment_type, on_done)
          end)
        end
      end)
    end

  2 function M.continue_template_creation_options(template)
**0   templates_view.get_option_choice(function(option_choice)
**0     if not option_choice or option_choice == "No options" then
**0       M.continue_template_creation_params(template)
**0       return
        end

**0     M.add_options_loop(template, function()
**0       M.continue_template_creation_params(template)
        end)
      end)
    end

  2 function M.add_options_loop(template, on_done)
**0   templates_view.get_user_input("Enter option name (or leave empty to finish):", nil, function(name)
**0     if not name or name == "" then
**0       on_done()
**0       return
        end
**0     templates_view.get_user_input("Enter value for " .. name .. ":", nil, function(value)
**0       if value and value ~= "" then
**0         template.options[name] = value
          else
**0         vim.notify("Option value cannot be empty", vim.log.levels.WARN)
          end
**0       M.add_options_loop(template, on_done)
        end)
      end)
    end

  2 function M.continue_template_creation_params(template)
**0   local params = M.extract_params(template)
**0   if #params > 0 then
**0     vim.notify("Found parameters: " .. table.concat(params, ", "), vim.log.levels.INFO)
**0     M.set_param_defaults_loop(template, params, 1, function()
**0       M.continue_template_creation_extract(template)
        end)
      else
**0     M.continue_template_creation_extract(template)
      end
    end

  2 function M.set_param_defaults_loop(template, params, index, on_done)
**0   if index > #params then
**0     on_done()
**0     return
      end
**0   local param = params[index]
**0   templates_view.get_user_input("Default value for parameter '" .. param .. "' (leave empty for no default):", nil, function(value)
**0     if value and value ~= "" then
**0       template.defaults[param] = value
        end
**0     M.set_param_defaults_loop(template, params, index + 1, on_done)
      end)
    end

  2 function M.continue_template_creation_extract(template)
**0   templates_view.confirm_extract(function(extract)
**0     template.extract = extract
**0     M.continue_template_creation_schema(template)
      end)
    end

  2 function M.continue_template_creation_schema(template)
**0   templates_view.get_schema_choice(function(schema_choice)
**0     if not schema_choice or schema_choice == "No schema" then
**0       M.finalize_template_creation(template)
**0       return
        end

**0     local schemas = require('llm.managers.schemas_manager').get_schemas()
**0     templates_view.select_schema(schemas, function(schema_name)
**0       if schema_name then
**0         template.schema = schema_name
          end
**0       M.finalize_template_creation(template)
        end)
      end)
    end

  2 function M.finalize_template_creation(template)
**0   vim.notify("Creating template '" .. template.name .. "'...", vim.log.levels.INFO)
**0   local success = M.save_template(
**0     template.name,
**0     template.prompt,
**0     template.system,
**0     template.model,
**0     template.options,
**0     template.fragments,
**0     template.system_fragments,
**0     template.defaults,
**0     template.extract,
        template.schema
      )

**0   if success then
**0     vim.notify("Template '" .. template.name .. "' created successfully", vim.log.levels.INFO)
**0     vim.defer_fn(function()
**0       M.manage_templates()
**0     end, 500)
      else
**0     vim.notify("Failed to create template '" .. template.name .. "'", vim.log.levels.ERROR)
**0     vim.defer_fn(function()
**0       M.manage_templates()
**0     end, 500)
      end
    end

    -- Populate the buffer with template management content
  2 function M.build_buffer_data(templates)
**0   local lines = {
        "# Template Management",
        "",
        "Navigate: [M]odels [P]lugins [K]eys [F]ragments [S]chemas",
        "Actions: [c]reate [r]un [e]dit [d]elete [v]iew details [q]uit",
        "──────────────────────────────────────────────────────────────",
        ""
      }

**0   local template_data = {}
**0   local line_to_template = {}
**0   local current_line = #lines + 1

**0   if #templates == 0 then
**0     table.insert(lines, "No templates found. Press 'c' to create one.")
      else
**0     for i, template in ipairs(templates) do
**0       local description = template.description or ""

**0       local entry_lines = {
**0         string.format("Template %d: %s", i, template.name),
**0         string.format("  Description: %s", description)
          }
**0       table.insert(entry_lines, "")

**0       local start_line = current_line
**0       local end_line = current_line + #entry_lines - 1

**0       for line_num = start_line, end_line do
**0         line_to_template[line_num] = template.name
          end

**0       template_data[template.name] = {
            index = i,
            description = description,
            start_line = start_line,
            end_line = end_line,
          }

**0       for _, line in ipairs(entry_lines) do
**0         table.insert(lines, line)
          end

**0       current_line = current_line + #entry_lines
        end
      end
**0   return lines, template_data, line_to_template
    end

    -- Populate the buffer with template management content
  2 function M.populate_templates_buffer(bufnr)
**0   local templates = M.get_templates()
**0   local lines, template_data, line_to_template = M.build_buffer_data(templates)

**0   v_api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)
**0   styles.setup_highlights()
**0   styles.setup_buffer_syntax(bufnr)
**0   vim.b[bufnr].line_to_template = line_to_template
**0   vim.b[bufnr].template_data = template_data
**0   vim.b[bufnr].templates = templates
    end

    -- Setup keymaps for the template management buffer
  2 function M.get_keymap_definitions(bufnr, manager_module)
**0   manager_module = manager_module or M
**0   return {
**0     { mode = 'n', lhs = 'c', rhs = string.format([[<Cmd>lua require('%s').create_template_from_manager(%d)<CR>]], manager_module.__name or 'llm.managers.templates_manager', bufnr) },
**0     { mode = 'n', lhs = 'r', rhs = string.format([[<Cmd>lua require('%s').run_template_under_cursor(%d)<CR>]], manager_module.__name or 'llm.managers.templates_manager', bufnr) },
**0     { mode = 'n', lhs = 'e', rhs = string.format([[<Cmd>lua require('%s').edit_template_under_cursor(%d)<CR>]], manager_module.__name or 'llm.managers.templates_manager', bufnr) },
**0     { mode = 'n', lhs = 'd', rhs = string.format([[<Cmd>lua require('%s').delete_template_under_cursor(%d)<CR>]], manager_module.__name or 'llm.managers.templates_manager', bufnr) },
**0     { mode = 'n', lhs = 'v', rhs = string.format([[<Cmd>lua require('%s').view_template_details_under_cursor(%d)<CR>]], manager_module.__name or 'llm.managers.templates_manager', bufnr) },
      }
    end

    -- Setup keymaps for the template management buffer
  2 function M.setup_templates_keymaps(bufnr, manager_module)
**0   local keymaps = M.get_keymap_definitions(bufnr, manager_module)
**0   for _, keymap in ipairs(keymaps) do
**0     v_api.nvim_buf_set_keymap(bufnr, keymap.mode, keymap.lhs, keymap.rhs, { noremap = true, silent = true })
      end
    end

  2 function M.create_template_from_manager(bufnr)
**0   require('llm.ui.unified_manager').close()
**0   vim.schedule(function()
**0     M.create_template()
      end)
    end

  2 function M.run_template_under_cursor(bufnr)
**0   local template_name, template_info = M.get_template_info_under_cursor(bufnr)
**0   if not template_name then
**0     vim.notify("No template found under cursor", vim.log.levels.ERROR)
**0     return
      end

**0     require('llm.ui.unified_manager').close()
**0     vim.schedule(function()
**0       M.run_template_with_params(template_name)
        end)
    end

  2 function M.edit_template_under_cursor(bufnr)
**0   local template_name, _ = M.get_template_info_under_cursor(bufnr)
**0   if not template_name then
**0     vim.notify("No template found under cursor", vim.log.levels.ERROR)
**0     return
      end
**0   require('llm.ui.unified_manager').close()
**0   vim.schedule(function()
**0     M.edit_template(template_name)
      end)
    end

  2 function M.delete_template_under_cursor(bufnr)
**0   local template_name, _ = M.get_template_info_under_cursor(bufnr)
**0   if not template_name then
**0     vim.notify("No template found under cursor", vim.log.levels.ERROR)
**0     return
      end

**0   templates_view.confirm_delete(template_name, function(confirmed)
**0     if not confirmed then return end
**0     vim.schedule(function()
**0       local success = M.delete_template(template_name)
**0       if success then
**0         vim.notify("Template '" .. template_name .. "' deleted", vim.log.levels.INFO)
**0         require('llm.ui.unified_manager').switch_view("Templates")
          else
**0         vim.notify("Failed to delete template", vim.log.levels.ERROR)
          end
        end)
      end)
    end

  2 function M.view_template_details_under_cursor(bufnr)
**0   local template_name, _ = M.get_template_info_under_cursor(bufnr)
**0   if not template_name then
**0     vim.notify("No template found under cursor", vim.log.levels.ERROR)
**0     return
      end

**0   local template = M.get_template_details(template_name)
**0   if not template then
**0     vim.notify("Failed to get template details for '" .. template_name .. "'", vim.log.levels.ERROR)
**0     return
      end

**0   require('llm.ui.unified_manager').close()
**0   vim.schedule(function()
**0     M.show_template_details(template_name, template)
      end)
    end

  2 function M.show_template_details(template_name, template)
**0   local detail_buf = v_api.nvim_create_buf(false, true)
**0   v_api.nvim_buf_set_option(detail_buf, "buftype", "nofile")
**0   v_api.nvim_buf_set_option(detail_buf, "bufhidden", "wipe")
**0   v_api.nvim_buf_set_option(detail_buf, "swapfile", false)
**0   v_api.nvim_buf_set_name(detail_buf, "Template Details: " .. template_name)

**0   local detail_win = require('llm.core.utils.ui').create_floating_window(detail_buf, 'LLM Template Details: ' .. template_name)

**0   local lines = { "# Template: " .. template_name, "" }
**0   if template.system and template.system ~= "" then
**0     table.insert(lines, "## System Prompt:"); table.insert(lines, ""); table.insert(lines, template.system); table.insert(lines, "")
      end
**0   if template.prompt and template.prompt ~= "" then
**0     table.insert(lines, "## Prompt:"); table.insert(lines, ""); table.insert(lines, template.prompt); table.insert(lines, "")
      end
**0   if template.model and template.model ~= "" then
**0     table.insert(lines, "## Model: " .. template.model); table.insert(lines, "")
      end
**0   if template.extract then
**0     table.insert(lines, "## Extract first code block: Yes"); table.insert(lines, "")
      end
**0   if template.schema then
**0     table.insert(lines, "## Schema: " .. template.schema); table.insert(lines, "")
      end
**0   table.insert(lines, ""); table.insert(lines, "Press [q]uit, [e]dit template, [r]un template")
**0   v_api.nvim_buf_set_lines(detail_buf, 0, -1, false, lines)

      local function set_detail_keymap(mode, lhs, rhs)
**0     v_api.nvim_buf_set_keymap(detail_buf, mode, lhs, rhs, { noremap = true, silent = true })
      end

**0   set_detail_keymap("n", "q", [[<cmd>lua vim.api.nvim_win_close(0, true)<CR>]])
**0   set_detail_keymap("n", "<Esc>", [[<cmd>lua vim.api.nvim_win_close(0, true)<CR>]])
**0   set_detail_keymap("n", "e", string.format([[<Cmd>lua require('llm.managers.templates_manager').edit_template_from_details('%s')<CR>]], template_name))
**0   set_detail_keymap("n", "r", string.format([[<Cmd>lua require('llm.managers.templates_manager').run_template_with_params('%s')<CR>]], template_name))

**0   styles.setup_buffer_styling(detail_buf)
    end

  2 function M.get_template_info_under_cursor(bufnr)
**0   local current_line = v_api.nvim_win_get_cursor(0)[1]
**0   local line_to_template = vim.b[bufnr].line_to_template
**0   local template_data = vim.b[bufnr].template_data
**0   if not line_to_template or not template_data then
**0     vim.notify("Buffer data missing", vim.log.levels.ERROR)
**0     return nil, nil
      end

**0   for template_name, data in pairs(template_data) do
**0     if current_line >= data.start_line and current_line <= data.end_line then
**0       return template_name, data
        end
      end

**0   return nil, nil
    end

  2 function M.manage_templates()
**0   require('llm.ui.unified_manager').open_specific_manager("Templates")
    end

  2 M.__name = 'llm.managers.templates_manager'

  2 function M.run_template_by_name(template_name)
**0   if not template_name or template_name == "" then
**0     vim.notify("No template name provided", vim.log.levels.ERROR)
**0     return
      end
**0   local templates = M.get_templates()
**0   local found = false
**0   for _, t in ipairs(templates) do
**0     if t.name == template_name then
**0       found = true
          break
        end
      end
**0   if not found then
**0     vim.notify("Template '" .. template_name .. "' not found", vim.log.levels.ERROR)
**0     return
      end
**0   require('llm.ui.unified_manager').close()
**0   vim.schedule(function()
**0     M.run_template_with_params(template_name)
      end)
    end

  2 function M.edit_template_from_details(template_name)
**0   v_api.nvim_win_close(0, true)
**0   vim.schedule(function()
**0     M.edit_template(template_name)
      end)
    end

  2 return M

==============================================================================
lua/llm/ui/styles.lua
==============================================================================
    -- llm/styles.lua - Centralized styling for llm-nvim
    -- License: Apache 2.0

  7 local M = {}

    -- Color palette
  7 M.colors = {
      -- Base colors
  7   blue = "#61afef",
  7   cyan = "#56b6c2",
  7   green = "#98c379",
  7   red = "#e06c75",
  7   purple = "#c678dd",
  7   yellow = "#e5c07b",
  7   orange = "#d19a66",
  7   gray = "#abb2bf",
  7   dark_gray = "#3b4048",
      
      -- Semantic colors (can be mapped to base colors)
  7   header = "#61afef",
  7   subheader = "#56b6c2",
  7   section = "#c678dd",
  7   action = "#e5c07b",
  7   content = "#abb2bf",
  7   success = "#98c379",
  7   error = "#e06c75",
  7   divider = "#3b4048",
  7   keybinding = "#e5c07b",
  7 }

    -- Highlight groups
  7 M.highlights = {
      -- Common highlight groups
  7   Header = { fg = M.colors.header, style = "bold" },
  7   SubHeader = { fg = M.colors.subheader, style = "bold" },
  7   Section = { fg = M.colors.section, style = "bold" },
  7   Action = { fg = M.colors.action, style = "bold" },
  7   Divider = { fg = M.colors.divider },
  7   Content = { fg = M.colors.content },
  7   Success = { fg = M.colors.success, style = "bold" },
  7   Error = { fg = M.colors.error },
  7   Custom = { fg = M.colors.yellow, style = "bold" },
  7   Keybinding = { fg = M.colors.keybinding, style = "bold" },
  7   NavKeybinding = { fg = M.colors.cyan, style = "bold" }, -- Added for navigation keys

      -- Checkbox and status states
  7   CheckboxInstalled = { fg = M.colors.success, style = "bold" },
  7   CheckboxAvailable = { fg = M.colors.error },
  7   Installed = { fg = M.colors.success, style = "bold", bg = "#333333" },
  7   NotInstalled = { fg = M.colors.error, style = "bold", bg = "#1a1a1a" },
  7   PluginInstalled = { fg = M.colors.green },
  7   PluginNotInstalled = { fg = M.colors.red },
      
      -- Model-specific highlights
  7   ModelOpenAI = { fg = M.colors.cyan },
  7   ModelAnthropic = { fg = M.colors.green },
  7   ModelMistral = { fg = M.colors.purple },
  7   ModelGemini = { fg = M.colors.yellow },
  7   ModelGroq = { fg = M.colors.blue },
  7   ModelLocal = { fg = M.colors.orange },
  7   ModelDefault = { fg = M.colors.success, style = "bold" },
  7   ModelAlias = { fg = M.colors.purple },
      
      -- Fragment-specific highlights
  7   FragmentHash = { fg = M.colors.blue },
  7   FragmentSource = { fg = M.colors.green },
  7   FragmentAliases = { fg = M.colors.purple },
  7   FragmentDate = { fg = M.colors.cyan },
  7   FragmentContent = { fg = M.colors.content },
      
      -- Key-specific highlights
  7   KeyAvailable = { fg = M.colors.success },
  7   KeyMissing = { fg = M.colors.error },
  7   KeyAction = { link = "LLMCustom" },
      
      -- Schema-specific highlights (using common highlight groups)
  7   SchemaHeader = { link = "LLMHeader" },
  7   SchemaSection = { link = "LLMSubHeader" },
  7   SchemaContent = { link = "LLMContent" },
  7   SchemaFooter = { link = "LLMAction" },
  7   SchemaName = { fg = M.colors.yellow, style = "bold" },
  7   SchemaId = { fg = M.colors.blue, style = "bold" },
  7   Success = { fg = M.colors.success, style = "bold" },
  7   Error = { fg = M.colors.error, style = "bold" },
      
      -- Template-specific highlights (using common highlight groups)
  7   TemplateHeader = { link = "LLMHeader" },
  7   TemplateSection = { link = "LLMSubHeader" },
  7   TemplateContent = { link = "LLMContent" },
  7   TemplateFooter = { link = "LLMAction" },
  7   TemplateName = { fg = M.colors.yellow, style = "bold" },
      
      -- Template-specific highlights
  7   TemplateHeader = { fg = M.colors.header, style = "bold" },
  7   TemplateSection = { fg = M.colors.section, style = "bold" },
  7   TemplateContent = { fg = M.colors.content },
  7   TemplateFooter = { fg = M.colors.action, style = "bold" },
  7   LoaderTitle = { fg = M.colors.purple, style = "bold" },
  7   LoaderUsage = { fg = M.colors.cyan },
  7 }

    -- Setup function to create all highlight groups
  7 function M.setup_highlights()
      -- Create highlight commands
**0   local highlight_cmds = {}
      
**0   for name, attrs in pairs(M.highlights) do
**0     local cmd = "highlight default LLM" .. name
        
**0     if attrs.link then
**0       cmd = cmd .. " link=" .. attrs.link
**0     elseif attrs.fg then
**0       cmd = cmd .. " guifg=" .. attrs.fg
          
**0       if attrs.bg then
**0         cmd = cmd .. " guibg=" .. attrs.bg
          end
          
**0       if attrs.style then
**0         cmd = cmd .. " gui=" .. attrs.style
          end
        end
        
**0     table.insert(highlight_cmds, cmd)
      end
      
      -- Execute all highlight commands
**0   for _, cmd in ipairs(highlight_cmds) do
        -- Execute each command separately to avoid errors stopping the whole batch
**0     pcall(vim.cmd, cmd)
      end
    end

    -- Define syntax patterns for different UI elements
  7 M.syntax_patterns = {
      -- Headers
  7   header = "syntax match LLMHeader /^#.*/",
  7   subheader = "syntax match LLMSubHeader /^##.*/",
      
      
      
      
      
      -- Action text
  7   action = "syntax match LLMAction /Press.*$/",
      
      -- Dividers
  7   divider = "syntax match LLMDivider /^─\\+$/",
      
      -- Custom items
  7   custom = "syntax match LLMCustom /\\[+\\].*/",
      
      -- Keybindings in brackets
  7   keybinding = "syntax match LLMKeybinding /\\[[a-z?]\\]/", -- Match action keys
  7   nav_keybinding = "syntax match LLMNavKeybinding /\\[[A-Z]\\]/", -- Match navigation keys (M, P, K, F, T, S)

      -- Section headers
  7   section = "syntax match LLMSection /^[A-Za-z][A-Za-z0-9 ]*:$/",
      
      -- Model-specific patterns
  7   model_openai = "syntax match LLMModelOpenAI /^OpenAI.*$\\|\\[ \\] OpenAI.*/",
  7   model_anthropic = "syntax match LLMModelAnthropic /^Anthropic.*$\\|\\[ \\] Anthropic.*/",
  7   model_mistral = "syntax match LLMModelMistral /^Mistral.*$\\|\\[ \\] Mistral.*/",
  7   model_gemini = "syntax match LLMModelGemini /^Gemini.*$\\|\\[ \\] Gemini.*/",
  7   model_groq = "syntax match LLMModelGroq /^Groq.*$\\|\\[ \\] Groq.*/",
  7   model_default = "syntax match LLMModelDefault /\\[✓\\].*/",
      
      -- Fragment-specific patterns
  7   fragment_hash = "syntax match LLMFragmentHash /^Fragment \\d\\+: [0-9a-f]\\+$/",
  7   fragment_source = "syntax match LLMFragmentSource /^  Source: .*$/",
  7   fragment_aliases = "syntax match LLMFragmentAliases /^  Aliases: .*$/",
  7   fragment_date = "syntax match LLMFragmentDate /^  Date: .*$/",
  7   fragment_content = "syntax match LLMFragmentContent /^  Content: .*$/",
      
      -- Key-specific patterns
  7   key_available = "syntax match LLMKeyAvailable /\\[✓\\].*/",
  7   key_missing = "syntax match LLMKeyMissing /\\[ \\].*/",
  7   key_action = "syntax match LLMCustom /^\\[+\\] Add custom key$/",
      
      -- Schema-specific patterns (using common highlight groups)
  7   schema_header = "syntax match LLMHeader /^# Schema:/",
  7   schema_section = "syntax match LLMSubHeader /^## .*$/",
  7   schema_footer = "syntax match LLMAction /^Press.*$/",
  7   schema_id = "syntax match LLMSchemaId /^Schema \\d\\+: [0-9a-f]\\+$/",
  7   schema_name = "syntax match LLMSchemaName /^  Name: .*$/",
  7   schema_description = "syntax match LLMContent /^  Description: .*$/",
      
      -- Template-specific patterns
  7   template_header = "syntax match LLMHeader /^# Template:/",
  7   template_section = "syntax match LLMSubHeader /^## .*$/",
  7   template_footer = "syntax match LLMAction /^Press.*$/",
  7   template_name = "syntax match LLMTemplateName /^Template \\d\\+: .*$/",
  7   template_description = "syntax match LLMContent /^  Description: .*$/",
  7   loader_title = "syntax match LLMLoaderTitle /^Loader \\d\\+: .*$/",
  7   loader_usage = "syntax match LLMLoaderUsage /^  Usage: .*$/",
  7 }

    -- Setup syntax highlighting for a buffer
  7 function M.setup_buffer_syntax(buf)
      -- Apply common syntax patterns to the buffer
**0   for name, pattern in pairs(M.syntax_patterns) do
        -- Use pcall to catch any syntax errors
**0     local success, err = pcall(function()
**0       vim.api.nvim_buf_call(buf, function()
**0         vim.cmd(pattern)
          end)
        end)
        
**0     if not success then
**0         local config = require('llm.config')
**0         if config.get('debug') then
**0             vim.notify("Syntax pattern error for " .. name .. ": " .. tostring(err), vim.log.levels.WARN)
            end
        end
      end
    end

    -- Setup all styling for a buffer
  7 function M.setup_buffer_styling(buf)
      -- Setup highlights
**0   M.setup_highlights()
      
      -- Setup syntax patterns
**0   M.setup_buffer_syntax(buf)
    end

  7 return M

==============================================================================
lua/llm/ui/ui.lua
==============================================================================
    -- lua/llm/ui.lua - UI functions for the llm-nvim plugin

  1 local M = {}
  1 local api = vim.api

  1 function M.display_in_buffer(bufnr, lines, syntax)
  1   api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)
  1   if syntax then
  1     vim.bo[bufnr].syntax = syntax
      end
    end

  1 function M.notify(message, level)
  1   vim.notify(message, level)
    end

  1 function M.get_input(prompt, on_confirm)
**0   vim.ui.input({ prompt = prompt }, on_confirm)
    end

  1 function M.select(items, opts, on_choice)
**0   vim.ui.select(items, opts, on_choice)
    end

  1 return M

==============================================================================
lua/llm/ui/unified_manager.lua
==============================================================================
    -- llm/ui/unified_manager.lua - Unified management window for llm-nvim
    -- License: Apache 2.0

  1 local M = {}

  1 local api = vim.api
  1 local ui = require('llm.core.utils.ui')
  1 local styles = require('llm.ui.styles')
  1 local text = require('llm.core.utils.text')

    -- Manager modules
  1 local models_manager = require('llm.managers.models_manager')
  1 local plugins_manager = require('llm.managers.plugins_manager')
  1 local keys_manager = require('llm.managers.keys_manager')
  1 local fragments_manager = require('llm.managers.fragments_manager')
  1 local templates_manager = require('llm.managers.templates_manager')
  1 local schemas_manager = require('llm.managers.schemas_manager')

    -- State for the unified window
  1 local state = {
  1   winid = nil,
  1   bufnr = nil,
  1   current_view = nil,
  1   last_view = "Models", -- Default to Models view first time
    }

    -- Get the last viewed manager
  1 function M.get_last_view()
**0   return state.last_view or "Models"
    end

    -- Available views and their corresponding manager functions
  1 local views = {
  1   Models = {
  1     populate = models_manager.populate_models_buffer,
  1     setup_keymaps = models_manager.setup_models_keymaps,
  1     title = "Models",
  1     manager_module = models_manager,
  1   },
  1   Plugins = {
  1     populate = plugins_manager.populate_plugins_buffer,
  1     setup_keymaps = plugins_manager.setup_plugins_keymaps,
  1     title = "Plugins",
  1     manager_module = plugins_manager,
  1   },
  1   Keys = {
  1     populate = keys_manager.populate_keys_buffer,
  1     setup_keymaps = keys_manager.setup_keys_keymaps,
  1     title = "API Keys",
  1     manager_module = keys_manager,
  1   },
  1   Fragments = {
  1     populate = fragments_manager.populate_fragments_buffer,
  1     setup_keymaps = fragments_manager.setup_fragments_keymaps,
  1     title = "Fragments",
  1     manager_module = fragments_manager,
  1   },
  1   Templates = {
  1     populate = templates_manager.populate_templates_buffer,
  1     setup_keymaps = templates_manager.setup_templates_keymaps,
  1     title = "Templates",
  1     manager_module = templates_manager,
  1   },
  1   Schemas = {
  1     populate = schemas_manager.populate_schemas_buffer,
  1     setup_keymaps = schemas_manager.setup_schemas_keymaps,
  1     title = "Schemas",
  1     manager_module = schemas_manager,
  1   },
    }

    -- Close the unified window
    local function close_window()
      -- Save current view as last_view before closing
**0   if state.current_view then
**0     state.last_view = state.current_view
      end

**0   if state.winid and api.nvim_win_is_valid(state.winid) then
**0     api.nvim_win_close(state.winid, true)
      end
**0   if state.bufnr and api.nvim_buf_is_valid(state.bufnr) then
        -- Check if buffer is listed before trying to delete
**0     if vim.fn.bufexists(state.bufnr) == 1 and vim.fn.buflisted(state.bufnr) == 1 then
**0       pcall(api.nvim_buf_delete, state.bufnr, { force = true })
**0     elseif vim.fn.bufexists(state.bufnr) == 1 then
          -- If buffer exists but is not listed (e.g., nofile), try deleting directly
**0       pcall(api.nvim_buf_delete, state.bufnr, { force = true })
        end
      end
**0   state.winid = nil
**0   state.bufnr = nil
**0   state.current_view = nil
    end

    -- Setup common keymaps for switching views
    local function setup_common_keymaps(bufnr)
      local function set_keymap(mode, lhs, rhs)
**0     api.nvim_buf_set_keymap(bufnr, mode, lhs, rhs, { noremap = true, silent = true })
      end

**0   set_keymap('n', 'q', '<Cmd>lua require("llm.ui.unified_manager").close()<CR>')
**0   set_keymap('n', '<Esc>', '<Cmd>lua require("llm.ui.unified_manager").close()<CR>')

      -- Keymaps to switch views
**0   set_keymap('n', 'M', '<Cmd>lua require("llm.ui.unified_manager").switch_view("Models")<CR>')
**0   set_keymap('n', 'P', '<Cmd>lua require("llm.ui.unified_manager").switch_view("Plugins")<CR>')
**0   set_keymap('n', 'K', '<Cmd>lua require("llm.ui.unified_manager").switch_view("Keys")<CR>')
**0   set_keymap('n', 'F', '<Cmd>lua require("llm.ui.unified_manager").switch_view("Fragments")<CR>')
**0   set_keymap('n', 'T', '<Cmd>lua require("llm.ui.unified_manager").switch_view("Templates")<CR>')
**0   set_keymap('n', 'S', '<Cmd>lua require("llm.ui.unified_manager").switch_view("Schemas")<CR>')
    end

    -- Switch the view within the unified window
  1 function M.switch_view(view_name)
**0   if not state.winid or not api.nvim_win_is_valid(state.winid) then
**0     M.open(view_name) -- Open if not already open
**0     return
      end


**0   if not views[view_name] then
**0     vim.notify("Invalid view: " .. view_name, vim.log.levels.ERROR)
**0     return
      end

**0   state.current_view = view_name
**0   local view_config = views[view_name]

      -- Clear the buffer
**0   api.nvim_buf_set_option(state.bufnr, 'modifiable', true)
**0   api.nvim_buf_set_lines(state.bufnr, 0, -1, false, {})

      -- Populate buffer with new view content
**0   local success, err = pcall(view_config.populate, state.bufnr)
**0   if not success then
**0     vim.notify("Error populating " .. view_name .. " view: " .. tostring(err), vim.log.levels.ERROR)
        -- Add error message to buffer
**0     api.nvim_buf_set_lines(state.bufnr, 0, -1, false, {
**0       "# Error loading " .. view_name .. " Manager",
          "",
**0       "Details: " .. tostring(err),
          "",
          "Press [q]uit or use navigation keys ([M]odels, [P]lugins, etc.)"
        })
      end

      -- Set buffer options
**0   api.nvim_buf_set_option(state.bufnr, 'modifiable', false)
**0   api.nvim_buf_set_name(state.bufnr, 'LLM Unified Manager (' .. view_config.title .. ')')
**0   api.nvim_win_set_config(state.winid, { title = ' LLM Unified Manager (' .. view_config.title .. ') ' })

      -- Setup syntax highlighting
**0   styles.setup_buffer_syntax(state.bufnr)

      -- Setup keymaps (common + view-specific)
      -- Setting new keymaps below will overwrite any previous ones for the same keys.
**0   setup_common_keymaps(state.bufnr)
**0   if view_config.setup_keymaps then
**0     pcall(view_config.setup_keymaps, state.bufnr, view_config.manager_module) -- Pass manager module if needed
      end
    end

    -- Open the unified window with a specific view
  1 function M.open(initial_view)
**0   initial_view = initial_view or "Models" -- Default view

**0   if not views[initial_view] then
**0     vim.notify("Invalid initial view: " .. initial_view, vim.log.levels.ERROR)
**0     return
      end

      -- Check if already open
**0   if state.winid and api.nvim_win_is_valid(state.winid) then
        -- If open but wrong view, switch view
**0     if state.current_view ~= initial_view then
**0       M.switch_view(initial_view)
        end
        -- Bring window to front if already open with correct view
**0     api.nvim_set_current_win(state.winid)
**0     return
      end

      -- Create buffer
**0   state.bufnr = api.nvim_create_buf(false, true)
**0   api.nvim_buf_set_option(state.bufnr, 'buftype', 'nofile')
**0   api.nvim_buf_set_option(state.bufnr, 'bufhidden', 'wipe')
**0   api.nvim_buf_set_option(state.bufnr, 'swapfile', false)

      -- Create window using ui function
**0   state.winid = ui.create_floating_window(state.bufnr, 'LLM Unified Manager')

      -- Switch to the initial view
**0   M.switch_view(initial_view)
    end

    -- Toggle the unified window
  1 function M.toggle(view_name)
**0   if not view_name or view_name == "" then
**0     view_name = state.last_view or "Models"
      else
**0     view_name = text.capitalize(view_name)
      end

**0   if state.winid and api.nvim_win_is_valid(state.winid) then
**0     close_window()
      else
**0     M.open(view_name)
      end
    end

    -- Get the last viewed manager
  1 function M.get_last_view()
**0   return state.last_view or "Models"
    end

    -- Close the unified window (public function)
  1 function M.close()
**0   close_window()
    end

    -- Function for individual managers to call when opened directly
  1 function M.open_specific_manager(view_name)
      -- Update last_view before opening
**0   if state.current_view then
**0     state.last_view = state.current_view
      end
**0   M.open(view_name)
    end

    -- Get all available view names for completion
  1 function M.get_views()
**0   local view_names = {}
**0   for name, _ in pairs(views) do
**0     table.insert(view_names, name:lower())
      end
**0   return view_names
    end

  1 return M

==============================================================================
lua/llm/ui/views/fragments_view.lua
==============================================================================
    -- llm/ui/views/fragments_view.lua - UI functions for fragment management
    -- License: Apache 2.0

  1 local M = {}

  1 local ui = require('llm.core.utils.ui')
  1 local api = vim.api

  1 function M.view_fragment(fragment_hash, fragment_info)
**0   local content_buf = api.nvim_create_buf(false, true)
**0   api.nvim_buf_set_option(content_buf, 'buftype', 'nofile')
**0   api.nvim_buf_set_option(content_buf, 'bufhidden', 'wipe')
**0   api.nvim_buf_set_option(content_buf, 'swapfile', false)
**0   api.nvim_buf_set_name(content_buf, 'Fragment: ' .. fragment_hash:sub(1, 8))

**0   ui.create_floating_window(content_buf, 'LLM Fragment Content')

**0   local content_lines = {
**0     "# Fragment: " .. fragment_hash,
**0     "Source: " .. (fragment_info.source or "unknown"),
**0     "Aliases: " .. (#fragment_info.aliases > 0 and table.concat(fragment_info.aliases, ", ") or "none"),
**0     "Date: " .. (fragment_info.datetime or "unknown"),
        "",
        "## Content:",
        "",
      }
**0   for line in fragment_info.content:gmatch("[^\r\n]+") do table.insert(content_lines, line) end
**0   api.nvim_buf_set_lines(content_buf, 0, -1, false, content_lines)

**0   api.nvim_buf_set_option(content_buf, 'modifiable', false)

**0   local filetype = "text"
**0   if fragment_info.source then
**0     local ext = fragment_info.source:match("%.([^%.]+)$")
**0     if ext then filetype = ext end
**0     if filetype == "js" then filetype = "javascript" end
**0     if filetype == "py" then filetype = "python" end
**0     if filetype == "md" then filetype = "markdown" end
      end
**0   api.nvim_buf_set_option(content_buf, 'filetype', filetype)

**0   api.nvim_buf_set_keymap(content_buf, 'n', 'q', [[<cmd>lua vim.api.nvim_win_close(0, true)<CR>]],
**0     { noremap = true, silent = true })
**0   api.nvim_buf_set_keymap(content_buf, 'n', '<Esc>', [[<cmd>lua vim.api.nvim_win_close(0, true)<CR>]],
**0     { noremap = true, silent = true })
    end

  1 function M.get_alias(callback)
**0   ui.floating_input({ prompt = "Enter alias for fragment: " }, callback)
    end

  1 function M.select_alias_to_remove(aliases, callback)
**0   vim.ui.select(aliases, { prompt = "Select alias to remove:" }, callback)
    end

  1 function M.confirm_remove_alias(alias, callback)
**0   ui.floating_confirm({
        prompt = "Remove alias '" .. alias .. "'?",
        on_confirm = function(confirmed)
**0       callback(confirmed == "Yes")
        end
      })
    end

  1 function M.get_prompt(callback)
**0     ui.floating_input({
**0         prompt = "Enter prompt to use with fragment: "
**0     }, callback)
    end

  1 function M.select_file(callback)
**0     vim.ui.input({ prompt = "Enter file path: ", completion = "file" }, function(path)
**0         callback(path)
        end)
    end

  1 function M.get_github_url(callback)
**0     vim.ui.input({ prompt = "Enter GitHub URL: " }, function(url)
**0         callback(url)
        end)
    end

  1 return M

==============================================================================
lua/llm/ui/views/keys_view.lua
==============================================================================
    -- llm/ui/views/keys_view.lua - UI functions for key management
    -- License: Apache 2.0

  5 local M = {}

  5 local ui = require('llm.core.utils.ui')

  5 function M.get_custom_key_name(callback)
**0   ui.floating_input({ prompt = "Enter custom key name:" }, callback)
    end

  5 function M.get_api_key(provider_name, callback)
**0   ui.floating_input({ prompt = "Enter API key for '" .. provider_name .. "':" }, callback)
    end

  5 function M.confirm_remove_key(provider_name, callback)
**0   ui.floating_confirm({
        prompt = "Remove key for '" .. provider_name .. "'?",
        on_confirm = function()
**0       callback()
        end
      })
    end

  5 return M

==============================================================================
lua/llm/ui/views/models_view.lua
==============================================================================
    -- llm/ui/views/models_view.lua - UI functions for model management
    -- License: Apache 2.0

  3 local M = {}

  3 local ui = require('llm.core.utils.ui')
  3 local api = vim.api

  3 function M.select_model(models, callback)
**0   vim.ui.select(models, {
        prompt = "Select LLM model:",
        format_item = function(item)
**0       return item.id
        end
**0   }, callback)
    end

  3 function M.get_alias(model_display_name, callback)
**0     ui.floating_input({ prompt = "Enter alias for model '" .. model_display_name .. "': " }, callback)
    end

  3 function M.select_alias_to_remove(aliases, callback)
**0     vim.ui.select(aliases, {
            prompt = "Select alias to remove:",
**0         format_item = function(item) return item end
**0     }, callback)
    end

  3 function M.confirm_remove_alias(alias, callback)
**0     ui.floating_confirm({
            prompt = "Remove alias '" .. alias .. "'?",
            on_confirm = function(choice)
**0             if choice == "Yes" then
**0                 callback()
                end
            end
        })
    end

  3 function M.get_custom_model_details(callback)
**0     local details = {}
**0     ui.floating_input({ prompt = "Enter Model ID (e.g., gpt-3.5-turbo-custom):" }, function(model_id)
**0         if not model_id or model_id == "" then
**0             vim.notify("Model ID cannot be empty. Aborted.", vim.log.levels.WARN)
**0             return
            end
**0         details.model_id = model_id

**0         ui.floating_input({ prompt = "Enter Model Name (display name, optional):" }, function(model_name)
**0             details.model_name = (model_name and model_name ~= "") and model_name or nil

**0             ui.floating_input({ prompt = "Enter API Base URL (optional):" }, function(api_base)
**0                 details.api_base = (api_base and api_base ~= "") and api_base or nil

**0                 ui.floating_input({ prompt = "Enter API Key Name (optional, from keys.json):" }, function(api_key_name)
**0                     details.api_key_name = (api_key_name and api_key_name ~= "") and api_key_name or nil
**0                     callback(details)
                    end)
                end)
            end)
        end)
    end

  3 return M

==============================================================================
lua/llm/ui/views/plugins_view.lua
==============================================================================
    -- llm/ui/views/plugins_view.lua - UI functions for plugin management
    -- License: Apache 2.0

  2 local M = {}

  2 local ui = require('llm.core.utils.ui')

  2 function M.confirm_uninstall(plugin_name, callback)
**0   ui.floating_confirm({
        prompt = "Uninstall " .. plugin_name .. "?",
        on_confirm = function(confirmed)
**0       callback(confirmed == "Yes")
        end
      })
    end

  2 return M

==============================================================================
lua/llm/ui/views/schemas_view.lua
==============================================================================
    -- llm/ui/views/schemas_view.lua - UI functions for schema management
    -- License: Apache 2.0

  2 local M = {}

  2 local ui = require('llm.core.utils.ui')
  2 local styles = require('llm.ui.styles')
  2 local api = vim.api

  2 function M.select_schema(schemas, callback)
**0   local schema_items = {}

**0   for _, schema in ipairs(schemas) do
**0     table.insert(schema_items, schema)
      end

**0   if #schema_items == 0 then
**0     vim.notify("No schemas found", vim.log.levels.INFO)
**0     return
      end

**0   table.sort(schema_items, function(a, b) return a.name < b.name end)

**0   vim.ui.select(schema_items, {
        prompt = "Select a schema to run:",
        format_item = function(item)
**0       return item.name .. " - " .. (item.description or "")
        end
**0   }, callback)
    end

  2 function M.get_schema_type(callback)
**0   vim.ui.select({
        "Regular schema",
        "Multi schema (array of items)"
**0   }, {
**0     prompt = "Schema type:"
**0   }, callback)
    end

  2 function M.get_input_source(callback)
**0   vim.ui.select({
        "Current buffer",
        "URL (will use curl)",
        "Enter text manually"
**0   }, {
**0     prompt = "Choose input source:"
**0   }, callback)
    end

  2 function M.get_url(callback)
**0   ui.floating_input({
        prompt = "Enter URL:",
**0   }, callback)
    end

  2 function M.get_schema_name(callback)
**0   ui.floating_input({
        prompt = "Enter schema name:",
**0   }, callback)
    end

  2 function M.get_schema_format(callback)
**0   ui.floating_confirm({
        prompt = "Select schema format:",
        on_confirm = callback,
      })
    end

  2 function M.get_alias(current_alias, callback)
**0   local prompt_text = current_alias and "Enter new alias (current: " .. current_alias .. "): " or
          "Enter alias for schema: "
**0   ui.floating_input({
        prompt = prompt_text,
        default = current_alias or "",
**0   }, callback)
    end

  2 function M.confirm_delete_alias(alias, callback)
**0   ui.floating_confirm({
        prompt = "Delete alias '" .. alias .. "'?",
        on_confirm = function(confirmed)
**0       callback(confirmed == "Yes")
        end,
      })
    end

  2 function M.show_details(schema_id, schema, manager)
**0   local detail_buf = api.nvim_create_buf(false, true)
**0   api.nvim_buf_set_option(detail_buf, "buftype", "nofile")
**0   api.nvim_buf_set_option(detail_buf, "bufhidden", "wipe")
**0   api.nvim_buf_set_option(detail_buf, "swapfile", false)
**0   api.nvim_buf_set_name(detail_buf, "Schema Details: " .. schema_id)

**0   local detail_win = ui.create_floating_window(detail_buf, 'LLM Schema Details: ' .. schema_id)

**0   local lines = { "# Schema: " .. schema_id, "" }
**0   if schema.name then
**0     table.insert(lines, "## Name: " .. schema.name); table.insert(lines, "")
      end
**0   table.insert(lines, "## Schema Definition:"); table.insert(lines, "")
**0   if schema.content then
**0     local success, parsed = pcall(vim.fn.json_decode, schema.content)
**0     if success then
**0       local formatted_json = vim.fn.json_encode(parsed)
**0       if formatted_json then
**0         local indent = "  "
**0         local current_indent = 0
**0         local formatted_lines = {}
**0         for line in formatted_json:gmatch("[^\r\n]+") do
**0           if line:match("}") or line:match("]") then
**0             current_indent = math.max(0, current_indent - 1)
              end
**0           table.insert(formatted_lines, string.rep(indent, current_indent) .. line)
**0           if line:match("{") or line:match("%[") then
**0             current_indent = current_indent + 1
              end
            end
**0         vim.list_extend(lines, formatted_lines)
          else
**0         for line in schema.content:gmatch("[^\r\n]+") do table.insert(lines, line) end
          end
        else
**0       for line in schema.content:gmatch("[^\r\n]+") do table.insert(lines, line) end
        end
      else
**0     table.insert(lines, "No schema content available")
      end
**0   table.insert(lines, ""); table.insert(lines, "Press [q]uit, [r]un schema, [e]dit schema, [a]dd alias, [d]elete alias")
**0   api.nvim_buf_set_lines(detail_buf, 0, -1, false, lines)

      local function set_detail_keymap(mode, lhs, rhs)
**0     api.nvim_buf_set_keymap(detail_buf, mode, lhs, rhs,
**0       { noremap = true, silent = true })
      end
**0   set_detail_keymap("n", "q", [[<cmd>lua vim.api.nvim_win_close(0, true)<CR>]])
**0   set_detail_keymap("n", "<Esc>", [[<cmd>lua vim.api.nvim_win_close(0, true)<CR>]])
**0   set_detail_keymap("n", "r",
**0     string.format([[<Cmd>lua require('llm.managers.schemas_manager').run_schema_from_details('%s')<CR>]], schema_id))
**0   set_detail_keymap("n", "e",
**0     string.format([[<Cmd>lua require('llm.managers.schemas_manager').edit_schema_from_details('%s')<CR>]], schema_id))
**0   set_detail_keymap("n", "a",
**0     string.format([[<Cmd>lua require('llm.managers.schemas_manager').set_alias_from_details('%s')<CR>]], schema_id))
**0   set_detail_keymap("n", "d",
**0     string.format([[<Cmd>lua require('llm.managers.schemas_manager').delete_alias_from_details('%s')<CR>]], schema_id))

**0   styles.setup_buffer_syntax(detail_buf)
    end

  2 return M

==============================================================================
lua/llm/ui/views/templates_view.lua
==============================================================================
    -- llm/ui/views/templates_view.lua - UI functions for template management
    -- License: Apache 2.0

  2 local M = {}

  2 local ui = require('llm.core.utils.ui')

  2 function M.select_template(templates, callback)
**0     local template_items = {}

**0     for _, template in ipairs(templates) do
**0         table.insert(template_items, template)
        end

**0     if #template_items == 0 then
**0         vim.notify("No templates found", vim.log.levels.INFO)
**0         return
        end

**0     table.sort(template_items, function(a,b) return a.name < b.name end)

**0     vim.ui.select(template_items, {
            prompt = "Select a template to run:",
            format_item = function(item)
**0             return item.name .. " - " .. (item.description or "")
            end
**0     }, callback)
    end

  2 function M.get_user_input(prompt, default, callback)
**0     ui.floating_input({
            prompt = prompt,
            default = default,
**0     }, callback)
    end

  2 function M.get_input_source(callback)
**0     vim.ui.select({
            "Current selection",
            "Current buffer",
            "URL (will use curl)"
**0     }, {
**0         prompt = "Choose input source:"
**0     }, callback)
    end

  2 function M.get_template_type(callback)
**0     vim.ui.select({
            "Regular prompt",
            "System prompt only",
            "Both system and regular prompt"
**0     }, {
**0         prompt = "Choose template type:"
**0     }, callback)
    end

  2 function M.get_model_choice(callback)
**0     vim.ui.select({
            "Use default model",
            "Select specific model"
**0     }, {
**0         prompt = "Model selection:"
**0     }, callback)
    end

  2 function M.select_model(models, callback)
**0     vim.ui.select(models, {
**0         prompt = "Select model for this template:"
**0     }, callback)
    end

  2 function M.get_fragment_choice(callback)
**0     vim.ui.select({
            "No fragments",
            "Add fragments",
            "Add system fragments"
**0     }, {
**0         prompt = "Do you want to add fragments?"
**0     }, callback)
    end

  2 function M.get_add_fragment_choice(callback)
**0     vim.ui.select({
            "Select from file browser",
            "Enter fragment path/URL",
            "Done adding fragments"
**0     }, {
**0         prompt = "Add fragment:"
**0     }, callback)
    end

  2 function M.get_add_system_fragment_choice(callback)
**0     vim.ui.select({
            "Select from file browser",
            "Enter fragment path/URL",
            "Done adding system fragments"
**0     }, {
**0         prompt = "Add system fragment:"
**0     }, callback)
    end

  2 function M.get_option_choice(callback)
**0     vim.ui.select({
            "No options",
            "Add options"
**0     }, {
**0         prompt = "Do you want to add model options (like temperature)?"
**0     }, callback)
    end

  2 function M.confirm_extract(callback)
**0     ui.floating_confirm({
            prompt = "Extract first code block from response?",
            on_confirm = function(choice)
**0             callback(choice == "Yes")
            end
        })
    end

  2 function M.get_schema_choice(callback)
**0     vim.ui.select({
            "No schema",
            "Select existing schema"
**0     }, {
**0         prompt = "Do you want to add a schema?"
**0     }, callback)
    end

  2 function M.select_schema(schemas, callback)
**0     local schema_names = {}
**0     for _, schema in ipairs(schemas) do
**0         table.insert(schema_names, schema.name)
        end
**0     table.sort(schema_names)

**0     if #schema_names == 0 then
**0         vim.notify("No schemas found", vim.log.levels.INFO)
**0         callback(nil)
**0         return
        end

**0     vim.ui.select(schema_names, {
**0         prompt = "Select schema:"
**0     }, callback)
    end

  2 function M.confirm_delete(template_name, callback)
**0     ui.floating_confirm({
            prompt = "Delete template '" .. template_name .. "'?",
            on_confirm = function(choice)
**0             if choice == "Yes" then
**0                 callback()
                end
            end
        })
    end

  2 return M

==============================================================================
Summary
==============================================================================

File                                   Hits Missed Coverage
-----------------------------------------------------------
lua/llm/api.lua                        24   22     52.17%
lua/llm/chat.lua                       74   44     62.71%
lua/llm/chat/buffer.lua                210  45     82.35%
lua/llm/chat/session.lua               62   74     45.59%
lua/llm/commands.lua                   93   167    35.77%
lua/llm/config.lua                     79   8      90.80%
lua/llm/core/data/cache.lua            26   1      96.30%
lua/llm/core/data/llm_cli.lua          8    1      88.89%
lua/llm/core/loaders.lua               83   0      100.00%
lua/llm/core/utils/file_utils.lua      37   21     63.79%
lua/llm/core/utils/job.lua             31   15     67.39%
lua/llm/core/utils/notify.lua          4    0      100.00%
lua/llm/core/utils/shell.lua           103  13     88.79%
lua/llm/core/utils/text.lua            71   9      88.75%
lua/llm/core/utils/ui.lua              175  23     88.38%
lua/llm/core/utils/validate.lua        17   18     48.57%
lua/llm/errors.lua                     54   3      94.74%
lua/llm/facade.lua                     37   1      97.37%
lua/llm/init.lua                       31   12     72.09%
lua/llm/managers/custom_openai.lua     88   185    32.23%
lua/llm/managers/fragments_manager.lua 63   81     43.75%
lua/llm/managers/keys_manager.lua      36   92     28.12%
lua/llm/managers/models_io.lua         17   0      100.00%
lua/llm/managers/models_manager.lua    92   282    24.60%
lua/llm/managers/plugins_manager.lua   86   116    42.57%
lua/llm/managers/schemas_manager.lua   122  287    29.83%
lua/llm/managers/templates_manager.lua 107  348    23.52%
lua/llm/ui/styles.lua                  116  24     82.86%
lua/llm/ui/ui.lua                      11   2      84.62%
lua/llm/ui/unified_manager.lua         62   75     45.26%
lua/llm/ui/views/fragments_view.lua    11   37     22.92%
lua/llm/ui/views/keys_view.lua         6    4      60.00%
lua/llm/ui/views/models_view.lua       9    23     28.12%
lua/llm/ui/views/plugins_view.lua      4    2      66.67%
lua/llm/ui/views/schemas_view.lua      14   71     16.47%
lua/llm/ui/views/templates_view.lua    17   63     21.25%
-----------------------------------------------------------
Total                                  2080 2169   48.95%
